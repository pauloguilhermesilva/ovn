AT_BANNER([OVN Interconnection Controller])
OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn-ic -- AZ register])

ovn_init_ic_db
ovn_start az1
ovn_start az2

OVS_WAIT_UNTIL([test 2 = `ovn-ic-sbctl show | wc -l`])

check ovn-ic-nbctl --wait=sb sync
AT_CHECK([ovn-ic-sbctl show], [0], [dnl
availability-zone az1
availability-zone az2
])

ovn_as az1
ovn-nbctl set NB_Global . name=az3
OVS_WAIT_UNTIL([ovn-ic-sbctl show | grep -q az3])
AT_CHECK([ovn-ic-sbctl show], [0], [dnl
availability-zone az2
availability-zone az3
])

ovn_as az2
ovn-nbctl set NB_Global . name=\"\"
OVS_WAIT_WHILE([ovn-ic-sbctl show | grep -q az2])
AT_CHECK([ovn-ic-sbctl show], [0], [dnl
availability-zone az3
])

OVN_CLEANUP_IC([az1], [az2])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn-ic -- AZ update in GW])
ovn_init_ic_db
net_add n1

ovn_start az1
sim_add gw-az1
as gw-az1

check ovs-vsctl add-br br-phys
ovn_az_attach az1 n1 br-phys 192.168.1.1
check ovs-vsctl set open . external-ids:ovn-is-interconn=true

az_uuid=$(fetch_column ic-sb:availability-zone _uuid name="az1")
ovn_as az1 ovn-nbctl set NB_Global . name="az2"

check ovn-ic-nbctl --wait=sb sync
check_column "$az_uuid" ic-sb:availability-zone _uuid name="az2"

# make sure that gateway still point to the same AZ with new name
check_column "$az_uuid" ic-sb:gateway availability_zone name="gw-az1"

OVN_CLEANUP_IC([az1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn-ic -- transit switch handling])

ovn_init_ic_db
ovn_start az1

# create fake chassis with vxlan encap to enforce requested tunnel key checks
ovn-sbctl chassis-add fakechassis vxlan 192.168.0.2

AT_CHECK([ovn-ic-nbctl ts-add ts1])
AT_CHECK([ovn-ic-nbctl --wait=sb ts-add ts2])

# Check ISB
check_row_count ic-sb:Datapath_Binding 1 transit_switch=ts1
check_row_count ic-sb:Datapath_Binding 1 transit_switch=ts2
check_column "ts1 ts2" ic-sb:Datapath_Binding transit_switch
check_column "ts1 ts2" nb:Logical_Switch name

ovn-nbctl --wait=hv sync

# Check SB DP key
ts1_key=$(fetch_column ic-sb:Datapath_Binding tunnel_key transit_switch=ts1)
check_column "$ts1_key" Datapath_Binding tunnel_key external_ids:interconn-ts=ts1

# Test delete
AT_CHECK([ovn-ic-nbctl --wait=sb ts-del ts1])
check_row_count ic-sb:Datapath_Binding 0 transit_switch=ts1
check_column ts2 ic-sb:Datapath_Binding transit_switch
check_column ts2 nb:Logical_Switch name

OVN_CLEANUP_IC([az1])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn-ic -- port-bindings deletion upon TS deletion])

ovn_init_ic_db
net_add n1

# 1 GW per AZ
for i in 1 2; do
    az=az$i
    ovn_start $az
    sim_add gw-$az
    as gw-$az
    check ovs-vsctl add-br br-phys
    ovn_az_attach $az n1 br-phys 192.168.1.$i
    check ovs-vsctl set open . external-ids:ovn-is-interconn=true
done

ovn_as az1

# create transit switch and connect to LR
check ovn-ic-nbctl --wait=sb ts-add ts1
check ovn-nbctl lr-add lr1
check ovn-nbctl lrp-add lr1 lrp1 00:00:00:00:00:01 10.0.0.1/24
check ovn-nbctl lrp-set-gateway-chassis lrp1 gw-az1

check ovn-nbctl lsp-add ts1 lsp1 -- \
    lsp-set-addresses lsp1 router -- \
    lsp-set-type lsp1 router -- \
    lsp-set-options lsp1 router-port=lrp1

wait_row_count Datapath_Binding 1 external_ids:interconn-ts=ts1

# Sync ic-sb DB to see the TS changes.
check ovn-ic-nbctl --wait=sb sync

AT_CHECK([ovn-ic-sbctl show | grep -A2 lsp1], [0], [dnl
        port lsp1
            transit switch: ts1
            address: [["00:00:00:00:00:01 10.0.0.1/24"]]
])

# remove transit switch and check if port_binding is deleted
check ovn-ic-nbctl --wait=sb ts-del ts1
check_row_count ic-sb:Port_Binding 0 logical_port=lsp1
for i in 1 2; do
    az=az$i
    ovn_as $az
    OVN_CLEANUP_SBOX(gw-$az)
    OVN_CLEANUP_AZ([$az])
done
OVN_CLEANUP_IC
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn-ic -- route deletion upon TS deletion])

ovn_init_ic_db
net_add n1

# 1 GW per AZ
for i in 1 2; do
    az=az$i
    ovn_start $az
    sim_add gw-$az
    as gw-$az
    check ovs-vsctl add-br br-phys
    ovn_az_attach $az n1 br-phys 192.168.1.$i
    check ovs-vsctl set open . external-ids:ovn-is-interconn=true
    check ovn-nbctl set nb-global . \
        options:ic-route-adv=true \
        options:ic-route-adv-default=true \
        options:ic-route-learn=true \
        options:ic-route-learn-default=true
done

create_ic_infra() {
    az_id=$1
    ts_id=$2
    az=az$1

    lsp=lsp${az_id}-${ts_id}
    lrp=lrp${az_id}-${ts_id}
    ts=ts${az_id}-${ts_id}
    lr=lr${az_id}-${ts_id}

    ovn_as $az

    check ovn-ic-nbctl --wait=sb ts-add $ts
    check ovn-nbctl lr-add $lr
    check ovn-nbctl --wait=sb lrp-add $lr $lrp 00:00:00:00:00:0$az_id 10.0.$az_id.1/24
    check ovn-nbctl lrp-set-gateway-chassis $lrp gw-$az

    check ovn-nbctl lsp-add $ts $lsp -- \
        lsp-set-addresses $lsp router -- \
        lsp-set-type $lsp router -- \
        lsp-set-options $lsp router-port=$lrp

    check ovn-nbctl --wait=sb lr-route-add $lr 192.168.0.0/16 10.0.$az_id.10
}

create_ic_infra 1 1
create_ic_infra 1 2
create_ic_infra 2 1
check ovn-ic-nbctl --wait=sb sync

ovn_as az1

check_row_count ic-sb:Route 3 ip_prefix=192.168.0.0/16

# remove transit switch 1 (from az1) and check if its route is deleted
# same route from another AZ and ts should remain, as
check ovn-ic-nbctl --wait=sb ts-del ts1-1
ovn-ic-sbctl list route
ovn-ic-nbctl list transit_switch
check_row_count ic-sb:route 2 ip_prefix=192.168.0.0/16
ovn-ic-sbctl list route

for i in 1 2; do
    az=az$i
    ovn_as $az
    OVN_CLEANUP_SBOX(gw-$az)
    OVN_CLEANUP_AZ([$az])
done
OVN_CLEANUP_IC
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn-ic -- duplicate NB route adv/learn])

ovn_init_ic_db
net_add n1

# 1 GW per AZ
for i in 1 2; do
    az=az$i
    ovn_start $az
    sim_add gw-$az
    as gw-$az
    check ovs-vsctl add-br br-phys
    ovn_az_attach $az n1 br-phys 192.168.1.$i
    check ovs-vsctl set open . external-ids:ovn-is-interconn=true
    check ovn-nbctl set nb-global . \
        options:ic-route-adv=true \
        options:ic-route-adv-default=true \
        options:ic-route-learn=true \
        options:ic-route-learn-default=true
done

ovn_as az1

# create transit switch and connect to LR
check ovn-ic-nbctl --wait=sb ts-add ts1
for i in 1 2; do
    ovn_as az$i

    check ovn-nbctl lr-add lr1
    check ovn-nbctl lrp-add lr1 lrp$i 00:00:00:00:0$i:01 10.0.$i.1/24
    check ovn-nbctl lrp-set-gateway-chassis lrp$i gw-az$i

    check ovn-nbctl --wait=sb lsp-add ts1 lsp$i -- \
        lsp-set-addresses lsp$i router -- \
        lsp-set-type lsp$i router -- \
        lsp-set-options lsp$i router-port=lrp$i
done

ovn_as az1

ovn-nbctl \
  --id=@id create logical-router-static-route ip_prefix=1.1.1.1/32 nexthop=10.0.1.10 -- \
  add logical-router lr1 static_routes @id

check ovn-ic-nbctl --wait=sb sync
check ovn-ic-nbctl --wait=sb sync
check_row_count ic-sb:route 1 ip_prefix=1.1.1.1/32

for i in 1 2; do
    az=az$i
    ovn_as $az
    OVN_CLEANUP_SBOX(gw-$az)
    OVN_CLEANUP_AZ([$az])
done

OVN_CLEANUP_IC
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn-ic -- gateway sync])

ovn_init_ic_db
net_add n1
ovn_start az1
ovn_start az2
sim_add gw1
as gw1
ovs-vsctl add-br br-phys
ovn_az_attach az1 n1 br-phys 192.168.0.1
ovs-vsctl set open . external-ids:ovn-is-interconn=true external-ids:hostname=gw1

OVS_WAIT_UNTIL([ovn_as az2 ovn-sbctl show | grep "192.168.0.1"])
AT_CHECK([ovn_as az2 ovn-sbctl show | sort -r], [0], [dnl
Chassis gw1
    hostname: gw1
    Encap vxlan
    Encap geneve
        options: {csum="true"}
        options: {csum="true"}
        ip: "192.168.0.1"
        ip: "192.168.0.1"
])

AT_CHECK([ovn_as az2 ovn-sbctl -f csv -d bare --no-headings --columns other_config list chassis], [0], [dnl
is-remote=true
])

ovs-vsctl set open . external-ids:ovn-is-interconn=false
OVS_WAIT_UNTIL([test "$(ovn_as az2 ovn-sbctl show)" = ""])

ovs-vsctl set open . external-ids:ovn-is-interconn=true
OVS_WAIT_UNTIL([ovn_as az2 ovn-sbctl show | grep gw1])

OVN_CLEANUP_SBOX(gw1)
OVS_WAIT_FOR_OUTPUT([ovn_as az2 ovn-sbctl show], [0], [dnl
])

# Test encap change
sim_add gw2
as gw2
ovs-vsctl add-br br-phys
ovn_az_attach az1 n1 br-phys 192.168.0.1
ovs-vsctl set open . external-ids:ovn-is-interconn=true
OVS_WAIT_UNTIL([ovn_as az2 ovn-sbctl show | grep "192.168.0.1"])
ovs-vsctl set open . external_ids:ovn-encap-ip=192.168.0.2
OVS_WAIT_UNTIL([ovn_as az2 ovn-sbctl show | grep "192.168.0.2"])
ovs-vsctl set open . external_ids:ovn-encap-type="geneve,stt"
OVS_WAIT_UNTIL([ovn_as az2 ovn-sbctl show | grep stt])

OVN_CLEANUP_SBOX(gw2)
OVN_CLEANUP_IC([az1], [az2])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn-ic -- port sync])

ovn_init_ic_db
ovn-ic-nbctl ts-add ts1
net_add n1
ovn_start az1
ovn_start az2
# sync IC-NB to IC-SB and AZs after AZs creation.
check ovn-ic-nbctl --wait=sb sync
sim_add gw1
as gw1
ovs-vsctl add-br br-phys
ovn_az_attach az1 n1 br-phys 192.168.0.1
ovs-vsctl set open . external-ids:ovn-is-interconn=true

ovn_as az1
# Create LRP and connect to TS
ovn-nbctl lr-add lr1
ovn-nbctl lrp-add lr1 lrp-lr1-ts1 aa:aa:aa:aa:aa:01 169.254.100.1/24
ovn-nbctl lsp-add ts1 lsp-ts1-lr1
ovn-nbctl lsp-set-addresses lsp-ts1-lr1 router
ovn-nbctl lsp-set-type lsp-ts1-lr1 router
ovn-nbctl --wait=hv lsp-set-options lsp-ts1-lr1 router-port=lrp-lr1-ts1
OVS_WAIT_UNTIL([ovn_as az2 ovn-nbctl show | grep lsp-ts1-lr1])
ovn_as az2 ovn-nbctl lsp-set-options lsp-ts1-lr1 requested-chassis=gw1

OVS_WAIT_FOR_OUTPUT([ovn_as az2 ovn-nbctl show | uuidfilt], [0], [dnl
switch <0> (ts1)
    port lsp-ts1-lr1
        type: remote
        addresses: [["aa:aa:aa:aa:aa:01 169.254.100.1/24"]]
])

OVS_WAIT_FOR_OUTPUT([ovn_as az2 ovn-sbctl -f csv -d bare --no-headings --columns logical_port,type list port_binding], [0], [dnl
lsp-ts1-lr1,remote
])

ovn-nbctl lrp-set-gateway-chassis lrp-lr1-ts1 gw1
OVS_WAIT_UNTIL([ovn_as az2 ovn-sbctl show | grep lsp-ts1-lr1])

ovn_as az2 ovn-nbctl lsp-set-options lsp-ts1-lr1 requested-chassis=""
ovn-nbctl lrp-del-gateway-chassis lrp-lr1-ts1 gw1
OVS_WAIT_WHILE([ovn_as az2 ovn-sbctl show | grep lsp-ts1-lr1])

ovn-nbctl set logical_router_port lrp-lr1-ts1 mac="\"aa:aa:aa:aa:aa:02\"" \
              networks="169.254.100.2/24 169.254.200.3/24"
OVS_WAIT_UNTIL([ovn_as az2 ovn-nbctl show | grep "aa:aa:aa:aa:aa:02 169.254.100.2/24 169.254.200.3/24"])

# Delete the router port from az1, the remote port in az2 should still remain
# but just lost address.
ovn-nbctl lrp-del lrp-lr1-ts1
OVS_WAIT_WHILE([ovn_as az2 ovn-nbctl show | grep "aa:aa:aa:aa:aa:02 169.254.100.2/24 169.254.200.3/24"])
AT_CHECK([ovn_as az2 ovn-nbctl show | uuidfilt], [0], [dnl
switch <0> (ts1)
    port lsp-ts1-lr1
        type: remote
])

# Delete the lsp from az1, the remote port in az2 should be gone
ovn-nbctl lsp-del lsp-ts1-lr1
OVS_WAIT_WHILE([ovn_as az2 ovn-nbctl show | grep lsp-ts1-lr1])

OVN_CLEANUP_SBOX(gw1)
OVN_CLEANUP_IC([az1], [az2])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn-ic -- route sync])

ovn_init_ic_db
ovn-ic-nbctl ts-add ts1

for i in 1 2; do
    ovn_start az$i
    ovn_as az$i
    check ovn-ic-nbctl --wait=sb sync
    # Enable route learning at AZ level
    ovn-nbctl set nb_global . options:ic-route-learn=true
    # Enable route advertising at AZ level
    ovn-nbctl set nb_global . options:ic-route-adv=true

    # Create LRP and connect to TS
    ovn-nbctl lr-add lr$i
    ovn-nbctl lrp-add lr$i lrp-lr$i-ts1 aa:aa:aa:aa:aa:0$i 169.254.100.$i/24
    ovn-nbctl lsp-add ts1 lsp-ts1-lr$i \
            -- lsp-set-addresses lsp-ts1-lr$i router \
            -- lsp-set-type lsp-ts1-lr$i router \
            -- lsp-set-options lsp-ts1-lr$i router-port=lrp-lr$i-ts1

    # Create static routes
    ovn-nbctl lr-route-add lr$i 10.11.$i.0/24 169.254.0.1

    # Create a src-ip route, which shouldn't be synced
    ovn-nbctl --policy=src-ip lr-route-add lr$i 10.22.$i.0/24 169.254.0.2
done

for i in 1 2; do
    OVS_WAIT_UNTIL([ovn_as az$i ovn-nbctl lr-route-list lr$i | grep learned])
done

AT_CHECK([ovn_as az1 ovn-nbctl lr-route-list lr1], [0], [dnl
IPv4 Routes
Route Table <main>:
             10.11.1.0/24               169.254.0.1 dst-ip
             10.11.2.0/24             169.254.100.2 dst-ip (learned)
             10.22.1.0/24               169.254.0.2 src-ip
])

# Delete route in AZ1, AZ2's learned route should be deleted.
ovn_as az1 ovn-nbctl lr-route-del lr1 10.11.1.0/24
ovn-ic-nbctl --wait=sb sync
ovn-ic-nbctl --wait=sb sync
AT_CHECK([ovn_as az2 ovn-nbctl lr-route-list lr2 | grep -c learned], [1], [dnl
0
])

# Add the route back
ovn_as az1 ovn-nbctl lr-route-add lr1 10.11.1.0/24 169.254.0.1
ovn-ic-nbctl --wait=sb sync
ovn-ic-nbctl --wait=sb sync
AT_CHECK([ovn_as az2 ovn-nbctl lr-route-list lr2 | grep -c learned], [0], [dnl
1
])

# Disable route-learning for AZ1
ovn_as az1 ovn-nbctl set nb_global . options:ic-route-learn=false
ovn-ic-nbctl --wait=sb sync
AT_CHECK([ovn_as az1 ovn-nbctl lr-route-list lr1], [0], [dnl
IPv4 Routes
Route Table <main>:
             10.11.1.0/24               169.254.0.1 dst-ip
             10.22.1.0/24               169.254.0.2 src-ip
])

# AZ1 should still advertise and AZ2 should still learn the route
AT_CHECK([ovn_as az2 ovn-nbctl lr-route-list lr2 | grep learned], [0], [ignore])

# Disable route-advertising for AZ1
ovn_as az1 ovn-nbctl set nb_global . options:ic-route-adv=false

# AZ2 shouldn't have the route learned, because AZ1 should have stopped
# advertising.
check ovn-ic-nbctl --wait=sb sync
check ovn-ic-nbctl --wait=sb sync
AT_CHECK([ovn_as az2 ovn-nbctl lr-route-list lr2], [0], [dnl
IPv4 Routes
Route Table <main>:
             10.11.2.0/24               169.254.0.1 dst-ip
             10.22.2.0/24               169.254.0.2 src-ip
])

# Add default route in AZ1
ovn_as az1 ovn-nbctl lr-route-add lr1 0.0.0.0/0 169.254.0.3

# Re-enable router-advertising & learn for AZ1
ovn_as az1 ovn-nbctl set nb_global . options:ic-route-adv=true
ovn_as az1 ovn-nbctl set nb_global . options:ic-route-learn=true
check ovn-ic-nbctl --wait=sb sync
check ovn-ic-nbctl --wait=sb sync

# Default route should NOT get advertised or learned, by default.
AT_CHECK([ovn_as az2 ovn-nbctl lr-route-list lr2], [0], [dnl
IPv4 Routes
Route Table <main>:
             10.11.1.0/24             169.254.100.1 dst-ip (learned)
             10.11.2.0/24               169.254.0.1 dst-ip
             10.22.2.0/24               169.254.0.2 src-ip
])

# Enable default route advertising in AZ1
ovn_as az1 ovn-nbctl set nb_global . options:ic-route-adv-default=true
OVS_WAIT_UNTIL([ovn-ic-sbctl list route | grep 0.0.0.0])

# Enable default route learning in AZ2
ovn_as az2 ovn-nbctl set nb_global . options:ic-route-learn-default=true
OVS_WAIT_UNTIL([ovn_as az2 ovn-nbctl lr-route-list lr2 | grep learned | grep 0.0.0.0])

# Test directly connected subnet route advertising.
ovn_as az1 ovn-nbctl lrp-add lr1 lrp-lr1-ls1 aa:aa:aa:aa:bb:01 "192.168.0.1/24"
OVS_WAIT_UNTIL([ovn_as az2 ovn-nbctl lr-route-list lr2 | grep learned | grep 192.168])

# Delete the directly connected subnet from AZ1, learned route should be
# removed from AZ2.
ovn_as az1 ovn-nbctl lrp-del lrp-lr1-ls1
OVS_WAIT_WHILE([ovn_as az2 ovn-nbctl lr-route-list lr2 | grep learned | grep 192.168])

# Test denylist routes
# Add back the directly connected 192.168 route.
ovn_as az1 ovn-nbctl lrp-add lr1 lrp-lr1-ls1 aa:aa:aa:aa:bb:01 "192.168.0.1/24"
OVS_WAIT_UNTIL([ovn_as az2 ovn-nbctl lr-route-list lr2 | grep learned | grep 192.168])
# Ensure AZ1 learned AZ2's 10.11.2.0 route as well.
OVS_WAIT_UNTIL([ovn_as az1 ovn-nbctl lr-route-list lr1 | grep learned | grep 10.11])
# Now black list 10.11.0.0/16 and 192.168.0.0/16 in AZ2.
ovn_as az2 ovn-nbctl set nb_global . options:ic-route-denylist="10.11.0.0/16,192.168.0.0/16"
# AZ2 shouldn't learn 192.168 route any more.
OVS_WAIT_WHILE([ovn_as az2 ovn-nbctl lr-route-list lr2 | grep learned | grep 192.168])
# AZ1 shouldn't learn 10.11 any more.
OVS_WAIT_WHILE([ovn_as az1 ovn-nbctl lr-route-list lr1 | grep learned | grep 10.11])

# cleanup
ovn-ic-nbctl --if-exists ts-del ts1
ovn_as az1 ovn-nbctl lr-del lr1
ovn_as az2 ovn-nbctl lr-del lr2

# Create new transit switches and LRs. Test topology is next:
# logical router (lr11) - transit switch (ts11) - logical router (lr12)
# logical router (lr21) - transit switch (ts22) - logical router (lr22)
#
# lr12 has static route 10.0.0.0/24 and directly connected network 192.168.0.0/24
for i in 1 2; do
    ovn_as az$i

    # Ensure route learning at AZ level
    ovn-nbctl set nb_global . options:ic-route-learn=true
    # Ensure route advertising at AZ level
    ovn-nbctl set nb_global . options:ic-route-adv=true
    # Drop denylist
    ovn-nbctl remove nb_global . options ic-route-denylist

    for j in 1 2; do
        ts=ts$j$j
        ovn-ic-nbctl --wait=sb --may-exist ts-add $ts

        # Create LRP and connect to TS
        lr=lr$j$i
        echo lr: $lr, ts: $ts
        ovn-nbctl lr-add $lr
        ovn-nbctl lrp-add $lr lrp-$lr-$ts aa:aa:aa:aa:aa:0$j 169.254.100.$i/24
        ovn-nbctl lsp-add $ts lsp-$ts-$lr \
                -- lsp-set-addresses lsp-$ts-$lr router \
                -- lsp-set-type lsp-$ts-$lr router \
                -- lsp-set-options lsp-$ts-$lr router-port=lrp-$lr-$ts
    done
done

# Create directly-connected routes
ovn_as az2 ovn-nbctl --wait=sb lrp-add lr12 lrp-lr12-ls2 aa:aa:aa:aa:bb:01 "192.168.0.1/24"
ovn_as az2 ovn-nbctl lr-route-add lr12 10.10.10.0/24 192.168.0.10
ovn_as az1 ovn-nbctl --wait=sb sync

echo az1
ovn_as az1 ovn-nbctl show
echo az2
ovn_as az2 ovn-nbctl show
check ovn-ic-nbctl --wait=sb sync
check ovn-ic-nbctl --wait=sb sync

# Test routes from lr12 were learned to lr11
AT_CHECK([ovn_as az1 ovn-nbctl lr-route-list lr11 |
             grep learned | awk '{print $1, $2}' | sort], [0], [dnl
10.10.10.0/24 169.254.100.2
192.168.0.0/24 169.254.100.2
])

# Test routes from lr12 didn't leak as learned to lr21
AT_CHECK([ovn_as az1 ovn-nbctl lr-route-list lr21], [0], [])

# cleanup
ovn-ic-nbctl --if-exists ts-del ts1
ovn_as az1 ovn-nbctl lr-del lr11
ovn_as az1 ovn-nbctl lr-del lr21
ovn_as az2 ovn-nbctl lr-del lr12
ovn_as az2 ovn-nbctl lr-del lr22

# check routes origin advertisement and learning

# setup topology with connected, static and source routes
ovn-ic-nbctl --wait=sb ts-add ts1
for i in 1 2; do
    ovn_as az$i

    # Enable route learning at AZ level
    ovn-nbctl set nb_global . options:ic-route-learn=true
    # Enable route advertising at AZ level
    ovn-nbctl set nb_global . options:ic-route-adv=true

    # Create LRP and connect to TS
    ovn-nbctl lr-add lr$i
    ovn-nbctl lrp-add lr$i lrp-lr$i-ts1 aa:aa:aa:aa:aa:0$i 169.254.100.$i/24
    ovn-nbctl lsp-add ts1 lsp-ts1-lr$i \
            -- lsp-set-addresses lsp-ts1-lr$i router \
            -- lsp-set-type lsp-ts1-lr$i router \
            -- lsp-set-options lsp-ts1-lr$i router-port=lrp-lr$i-ts1

    ovn-nbctl lrp-add lr$i lrp-lr$i-p$i 00:00:00:00:00:0$i 192.168.$i.1/24

    # Create static routes
    ovn-nbctl --wait=sb lr-route-add lr$i 10.11.$i.0/24 169.254.0.1

    # Create a src-ip route, which shouldn't be synced
    ovn-nbctl --policy=src-ip lr-route-add lr$i 10.22.$i.0/24 169.254.0.2
done

check ovn-ic-nbctl --wait=sb sync
# check that advertised routes in ic-sb have correct origin
ovn-ic-sbctl list route
wait_row_count ic-sb:Route 1 ip_prefix=10.11.1.0/24 origin=static
wait_row_count ic-sb:Route 1 ip_prefix=192.168.1.1/24 origin=connected
wait_row_count ic-sb:Route 1 ip_prefix=10.11.2.0/24 origin=static
wait_row_count ic-sb:Route 1 ip_prefix=192.168.2.1/24 origin=connected

# check that learned routes in ic-sb have correct origin

ovn_as az1
wait_row_count nb:Logical_Router_Static_Route 1 ip_prefix=10.11.2.0/24 options:origin=static
wait_row_count nb:Logical_Router_Static_Route 1 ip_prefix=192.168.2.1/24 options:origin=connected

ovn_as az2
wait_row_count nb:Logical_Router_Static_Route 1 ip_prefix=10.11.1.0/24 options:origin=static
wait_row_count nb:Logical_Router_Static_Route 1 ip_prefix=192.168.1.1/24 options:origin=connected

OVN_CLEANUP_IC([az1], [az2])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn-ic -- route sync -- IPv6 route tables])
AT_KEYWORDS([IPv6-route-sync])

ovn_init_ic_db
ovn-ic-nbctl ts-add ts1

for i in 1 2; do
    ovn_start az$i
    ovn_as az$i
    # Enable route learning at AZ level
    ovn-nbctl set nb_global . options:ic-route-learn=true
    # Enable route advertising at AZ level
    ovn-nbctl set nb_global . options:ic-route-adv=true
    check ovn-ic-nbctl --wait=sb sync

    # Create LRP and connect to TS
    ovn-nbctl lr-add lr$i
    ovn-nbctl lrp-add lr$i lrp-lr$i-ts1 aa:aa:aa:aa:aa:0$i 2001:db8:1::$i/64
    ovn-nbctl lsp-add ts1 lsp-ts1-lr$i \
            -- lsp-set-addresses lsp-ts1-lr$i router \
            -- lsp-set-type lsp-ts1-lr$i router \
            -- lsp-set-options lsp-ts1-lr$i router-port=lrp-lr$i-ts1

    ovn-nbctl --wait=sb lrp-add lr$i lrp-lr$i-p$i 00:00:00:00:00:0$i 2002:db8:1::$i/64
done

check ovn-ic-nbctl --wait=sb sync
check ovn-ic-nbctl --wait=sb sync
AT_CHECK([ovn_as az1 ovn-nbctl lr-route-list lr1 | awk '/learned/{print $1, $2}'], [0], [dnl
2002:db8:1::/64 2001:db8:1::2
])

# Do not learn routes from link-local nexthops
for i in 1 2; do
    ovn_as az$i
    ovn-nbctl lrp-del lrp-lr$i-ts1
    ovn-nbctl lrp-add lr$i lrp-lr$i-ts1 aa:aa:aa:aa:aa:0$i 169.254.100.$i/24
done

OVS_WAIT_WHILE([ovn_as az1 ovn-nbctl lr-route-list lr1 | grep learned])
AT_CHECK([ovn_as az1 ovn-nbctl lr-route-list lr1 | grep -q learned], [1])

OVN_CLEANUP_IC([az1], [az2])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn-ic -- route sync -- route tables])

ovn_init_ic_db
ovn-ic-nbctl ts-add ts1

for i in 1 2; do
    ovn_start az$i
    ovn_as az$i
    check ovn-ic-nbctl --wait=sb sync
    # Enable route learning at AZ level
    ovn-nbctl set nb_global . options:ic-route-learn=true
    # Enable route advertising at AZ level
    ovn-nbctl set nb_global . options:ic-route-adv=true

    # Create LRP and connect to TS
    ovn-nbctl lr-add lr$i
    ovn-nbctl lrp-add lr$i lrp-lr$i-ts1 aa:aa:aa:aa:aa:0$i 169.254.100.$i/24
    ovn-nbctl lsp-add ts1 lsp-ts1-lr$i \
            -- lsp-set-addresses lsp-ts1-lr$i router \
            -- lsp-set-type lsp-ts1-lr$i router \
            -- lsp-set-options lsp-ts1-lr$i router-port=lrp-lr$i-ts1

    # Create static routes
    ovn-nbctl lr-route-add lr$i 10.11.$i.0/24 169.254.0.1

    # Create a src-ip route, which shouldn't be synced
    ovn-nbctl --policy=src-ip --route-table=rtb1 lr-route-add lr$i 10.22.$i.0/24 169.254.0.2
done

check ovn-ic-nbctl --wait=sb sync
check ovn-ic-nbctl --wait=sb sync
AT_CHECK([ovn_as az1 ovn-nbctl lr-route-list lr1], [0], [dnl
IPv4 Routes
Route Table <main>:
             10.11.1.0/24               169.254.0.1 dst-ip
             10.11.2.0/24             169.254.100.2 dst-ip (learned)

Route Table rtb1:
             10.22.1.0/24               169.254.0.2 src-ip
])

# move routes from <main> route table to rtb1
for i in 1 2; do
    ovn_as az$i ovn-nbctl lr-route-del lr$i 10.11.$i.0/24 169.254.0.1
    ovn_as az$i ovn-nbctl --route-table=rtb1 lr-route-add lr$i 10.11.$i.0/24 169.254.0.1
done

check ovn-ic-nbctl --wait=sb sync
check ovn-ic-nbctl --wait=sb sync
# ensure route from rtb1 is not learned to any route table as route table is
# not set to TS port
AT_CHECK([ovn_as az1 ovn-nbctl lr-route-list lr1], [0], [dnl
IPv4 Routes
Route Table rtb1:
             10.11.1.0/24               169.254.0.1 dst-ip
             10.22.1.0/24               169.254.0.2 src-ip
])

# assign route table rtb1 to TS port on AZ2 and check routes are advertised to IC SB DB
check ovn_as az2 ovn-nbctl lrp-set-options lrp-lr2-ts1 route_table=rtb1
check ovn-ic-nbctl --wait=sb sync

# ensure route was not learned as on AZ1 TS port's LRP was not set to route table rtb1
AT_CHECK([ovn_as az1 ovn-nbctl lr-route-list lr1], [0], [dnl
IPv4 Routes
Route Table rtb1:
             10.11.1.0/24               169.254.0.1 dst-ip
             10.22.1.0/24               169.254.0.2 src-ip
])

# set TS port's LRP to route table rtb1 to learn routes from AZ2 from rtb1
check ovn_as az1 ovn-nbctl lrp-set-options lrp-lr1-ts1 route_table=rtb1
check ovn-ic-nbctl --wait=sb sync

AT_CHECK([ovn_as az1 ovn-nbctl lr-route-list lr1], [0], [dnl
IPv4 Routes
Route Table rtb1:
             10.11.1.0/24               169.254.0.1 dst-ip
             10.11.2.0/24             169.254.100.2 dst-ip (learned)
             10.22.1.0/24               169.254.0.2 src-ip
])

# Delete route in AZ1, AZ2's learned route should be deleted.
ovn_as az1 ovn-nbctl --route-table=rtb1 lr-route-del lr1 10.11.1.0/24
OVS_WAIT_WHILE([ovn_as az2 ovn-nbctl --route-table=rtb1 lr-route-list lr2 | grep learned])

# Add the route back
ovn_as az1 ovn-nbctl --route-table=rtb1 lr-route-add lr1 10.11.1.0/24 169.254.0.1
OVS_WAIT_UNTIL([ovn_as az2 ovn-nbctl lr-route-list lr2 | grep learned])

# Disable route-learning for AZ1
ovn_as az1 ovn-nbctl set nb_global . options:ic-route-learn=false
OVS_WAIT_WHILE([ovn_as az1 ovn-nbctl lr-route-list lr1 | grep learned])
AT_CHECK([ovn_as az1 ovn-nbctl lr-route-list lr1], [0], [dnl
IPv4 Routes
Route Table rtb1:
             10.11.1.0/24               169.254.0.1 dst-ip
             10.22.1.0/24               169.254.0.2 src-ip
])

# AZ1 should still advertise and AZ2 should still learn the route
AT_CHECK([ovn_as az2 ovn-nbctl lr-route-list lr2 | grep learned], [0], [ignore])
AT_CHECK([ovn_as az2 ovn-nbctl lr-route-list lr2], [0], [dnl
IPv4 Routes
Route Table rtb1:
             10.11.1.0/24             169.254.100.1 dst-ip (learned)
             10.11.2.0/24               169.254.0.1 dst-ip
             10.22.2.0/24               169.254.0.2 src-ip
])

# Disable route-advertising for AZ1
ovn_as az1 ovn-nbctl set nb_global . options:ic-route-adv=false

# AZ2 shouldn't have the route learned, because AZ1 have stopped advertising.
OVS_WAIT_WHILE([ovn_as az2 ovn-nbctl lr-route-list lr2 | grep learned])

# Add default route in AZ1
ovn_as az1 ovn-nbctl --route-table=rtb1 lr-route-add lr1 0.0.0.0/0 169.254.0.3

# Re-enable router-advertising & learn for AZ1
ovn_as az1 ovn-nbctl set nb_global . options:ic-route-adv=true
ovn_as az1 ovn-nbctl set nb_global . options:ic-route-learn=true

for i in 1 2; do
    OVS_WAIT_UNTIL([ovn_as az$i ovn-nbctl lr-route-list lr$i | grep learned])
done

# Default route should NOT get advertised or learned, by default.
AT_CHECK([ovn-ic-sbctl find route ip_prefix="0.0.0.0/0"], [0], [])

# Enable default route advertising in AZ1, ensure it advertised, but not learned
ovn_as az1 ovn-nbctl set nb_global . options:ic-route-adv-default=true
OVS_WAIT_UNTIL([ovn-ic-sbctl find route ip_prefix="0.0.0.0/0" route_table=rtb1 | grep 0.0.0.0])
OVS_WAIT_WHILE([ovn_as az2 ovn-nbctl --route-table=rtb1 lr-route-list lr2 | grep learned | grep 0.0.0.0])

# Enable default route learning in AZ2
ovn_as az2 ovn-nbctl set nb_global . options:ic-route-learn-default=true
OVS_WAIT_UNTIL([ovn_as az2 ovn-nbctl --route-table=rtb1 lr-route-list lr2 | grep learned | grep 0.0.0.0])

# Test directly connected subnet route advertising. Route should go to <main> route table.
ovn_as az1 ovn-nbctl lrp-add lr1 lrp-lr1-ls1 aa:aa:aa:aa:bb:01 "192.168.0.1/24"
OVS_WAIT_UNTIL([ovn-ic-sbctl find route ip_prefix="192.168.0.1/24" route_table="\"\"" | grep 192.168.0.1/24])
OVS_WAIT_UNTIL([ovn_as az2 ovn-nbctl lr-route-list lr2 | grep learned | grep 192.168])
AT_CHECK([ovn_as az2 ovn-nbctl lr-route-list lr2], [0], [dnl
IPv4 Routes
Route Table <main>:
           192.168.0.0/24             169.254.100.1 dst-ip (learned)

Route Table rtb1:
             10.11.1.0/24             169.254.100.1 dst-ip (learned)
             10.11.2.0/24               169.254.0.1 dst-ip
             10.22.2.0/24               169.254.0.2 src-ip
                0.0.0.0/0             169.254.100.1 dst-ip (learned)
])

# Delete the directly connected subnet from AZ1, learned route should be
# removed from AZ2.
ovn_as az1 ovn-nbctl lrp-del lrp-lr1-ls1
OVS_WAIT_WHILE([ovn_as az2 ovn-nbctl lr-route-list lr2 | grep learned | grep 192.168])

# Test denylist routes
# Add back the directly connected 192.168 route.
ovn_as az1 ovn-nbctl lrp-add lr1 lrp-lr1-ls1 aa:aa:aa:aa:bb:01 "192.168.0.1/24"
OVS_WAIT_UNTIL([ovn_as az2 ovn-nbctl lr-route-list lr2 | grep learned | grep 192.168])
# Now add 10.11.0.0/16 and 192.168.0.0/16 to denylist in AZ2.
check ovn_as az2 ovn-nbctl set nb_global . options:ic-route-denylist="10.11.0.0/16,192.168.0.0/16"
# AZ2 shouldn't learn 192.168 route any more.
OVS_WAIT_WHILE([ovn_as az2 ovn-nbctl lr-route-list lr2 | grep learned | grep 192.168])
# AZ1 shouldn't learn 10.11 any more.
OVS_WAIT_WHILE([ovn_as az1 ovn-nbctl lr-route-list lr1 | grep learned | grep 10.11])
AT_CHECK([ovn_as az2 ovn-nbctl lr-route-list lr2], [0], [dnl
IPv4 Routes
Route Table rtb1:
             10.11.2.0/24               169.254.0.1 dst-ip
             10.22.2.0/24               169.254.0.2 src-ip
                0.0.0.0/0             169.254.100.1 dst-ip (learned)
])

OVN_CLEANUP_IC([az1], [az2])

AT_CLEANUP
])


OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn-ic -- route sync -- multiple route tables])

ovn_init_ic_db
ovn-ic-nbctl ts-add ts1

for i in 1 2; do
    ovn_start az$i
    ovn_as az$i

    # Enable route learning at AZ level
    ovn-nbctl set nb_global . options:ic-route-learn=true
    # Enable route advertising at AZ level
    ovn-nbctl set nb_global . options:ic-route-adv=true
done

# Create new transit switches and LRs. Test topology is next:
# VPC1:
#                       / transit switch (ts11) \
# logical router (lr11) - transit switch (ts12) - logical router (lr12)
#                       \ transit switch (ts13) /
#
# VPC2:
#                       / transit switch (ts21) \
# logical router (lr21)                           logical router (lr22)
#                       \ transit switch (ts22) /
#
# each LR has one connected subnet except TS port


# VPC1
# create lr11, lr12, ts11, ts12, ts13 and connect them
# assign route tables rtb1, rtb2, rtb3 to ts ports
for i in 1 2; do
    ovn_as az$i

    lr=lr1$i
    ovn-nbctl lr-add $lr

    for j in 1 2 3; do
        ts=ts1$j
        ovn-ic-nbctl --wait=sb --may-exist ts-add $ts

        lrp=lrp-$lr-$ts
        lsp=lsp-$ts-$lr
        # Create LRP and connect to TS
        ovn-nbctl lrp-add $lr $lrp aa:aa:aa:aa:a$j:0$i 169.254.10$j.$i/24
        ovn-nbctl lrp-set-options $lrp route_table=rtb$j
        ovn-nbctl lsp-add $ts $lsp \
                -- lsp-set-addresses $lsp router \
                -- lsp-set-type $lsp router \
                -- lsp-set-options $lsp router-port=$lrp
    done
done

# VPC2
# create lr21, lr22, ts21, ts22 and connect them
# assign route tables rtb1, rtb2, rtb3 to ts ports
for i in 1 2; do
    ovn_as az$i

    lr=lr2$i
    ovn-nbctl lr-add $lr

    for j in 1 2; do
        ts=ts2$j
        ovn-ic-nbctl --wait=sb --may-exist ts-add $ts

        lrp=lrp-$lr-$ts
        lsp=lsp-$ts-$lr
        # Create LRP and connect to TS
        ovn-nbctl lrp-add $lr $lrp aa:aa:aa:aa:a$j:0$i 169.254.10$j.$i/24
        ovn-nbctl lrp-set-options $lrp route_table=rtb$j
        ovn-nbctl lsp-add $ts $lsp \
                -- lsp-set-addresses $lsp router \
                -- lsp-set-type $lsp router \
                -- lsp-set-options $lsp router-port=$lrp
    done
done

# Create directly-connected and static routes in VPC1
ovn_as az2 ovn-nbctl lrp-add lr12 lrp-lr12 aa:aa:aa:aa:bb:01 "192.168.0.1/24"
ovn_as az2 ovn-nbctl --route-table=rtb1 lr-route-add lr12 10.10.10.0/24 192.168.0.10
ovn_as az2 ovn-nbctl --route-table=rtb2 lr-route-add lr12 10.10.10.0/24 192.168.0.11
ovn_as az2 ovn-nbctl --route-table=rtb3 lr-route-add lr12 10.10.10.0/24 192.168.0.12

# Create directly-connected route in VPC2
ovn_as az2 ovn-nbctl --wait=sb lrp-add lr22 lrp-lr22 aa:aa:aa:aa:bb:01 "192.168.0.1/24"
check ovn-ic-nbctl --wait=sb sync
check ovn-ic-nbctl --wait=sb sync
# Test direct routes from lr12 were learned to lr11
OVS_WAIT_FOR_OUTPUT([ovn_as az1 ovn-nbctl lr-route-list lr11 | grep 192.168 |
             grep learned | awk '{print $1, $2, $5}' | sort ], [0], [dnl
192.168.0.0/24 169.254.101.2 ecmp
192.168.0.0/24 169.254.102.2 ecmp
192.168.0.0/24 169.254.103.2 ecmp
])

# Test static routes from lr12 rtbs rtb1,rtb2,rtb3 were learned to lr11
OVS_WAIT_FOR_OUTPUT([ovn_as az1 ovn-nbctl --route-table=rtb1 lr-route-list lr11], [0], [dnl
IPv4 Routes
Route Table rtb1:
            10.10.10.0/24             169.254.101.2 dst-ip (learned)
])
OVS_WAIT_FOR_OUTPUT([ovn_as az1 ovn-nbctl --route-table=rtb2 lr-route-list lr11], [0], [dnl
IPv4 Routes
Route Table rtb2:
            10.10.10.0/24             169.254.102.2 dst-ip (learned)
])
OVS_WAIT_FOR_OUTPUT([ovn_as az1 ovn-nbctl --route-table=rtb3 lr-route-list lr11], [0], [dnl
IPv4 Routes
Route Table rtb3:
            10.10.10.0/24             169.254.103.2 dst-ip (learned)
])

# Test routes from lr12 didn't leak as learned to lr21
OVS_WAIT_FOR_OUTPUT([ovn_as az1 ovn-nbctl lr-route-list lr21 | grep 192.168 | sort], [0], [dnl
           192.168.0.0/24             169.254.101.2 dst-ip (learned) ecmp
           192.168.0.0/24             169.254.102.2 dst-ip (learned) ecmp
])

OVN_CLEANUP_IC([az1], [az2])

AT_CLEANUP
])


OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn-ic -- route sync -- multiple route tables IPv6])

ovn_init_ic_db
ovn-ic-nbctl ts-add ts1

for i in 1 2; do
    ovn_start az$i
    ovn_as az$i

    # Enable route learning at AZ level
    ovn-nbctl set nb_global . options:ic-route-learn=true
    # Enable route advertising at AZ level
    ovn-nbctl set nb_global . options:ic-route-adv=true
done

# Create new transit switches and LRs. Test topology is next:
# VPC1:
#                       / transit switch (ts11) \
# logical router (lr11) - transit switch (ts12) - logical router (lr12)
#                       \ transit switch (ts13) /
#
# VPC2:
#                       / transit switch (ts21) \
# logical router (lr21)                           logical router (lr22)
#                       \ transit switch (ts22) /
#
# each LR has one connected subnet except TS port


# VPC1
# create lr11, lr12, ts11, ts12, ts13 and connect them
# assign route tables rtb1, rtb2, rtb3 to ts ports
for i in 1 2; do
    ovn_as az$i

    lr=lr1$i
    ovn-nbctl lr-add $lr

    for j in 1 2 3; do
        ts=ts1$j
        ovn-ic-nbctl --wait=sb --may-exist ts-add $ts

        lrp=lrp-$lr-$ts
        lsp=lsp-$ts-$lr
        # Create LRP and connect to TS
        ovn-nbctl lrp-add $lr $lrp aa:aa:aa:aa:a$j:0$i 2001:db8:$j::$i/64
        ovn-nbctl lrp-set-options $lrp route_table=rtb$j
        ovn-nbctl lsp-add $ts $lsp \
                -- lsp-set-addresses $lsp router \
                -- lsp-set-type $lsp router \
                -- lsp-set-options $lsp router-port=$lrp
    done
done

# VPC2
# create lr21, lr22, ts21, ts22 and connect them
# assign route tables rtb1, rtb2, rtb3 to ts ports
for i in 1 2; do
    ovn_as az$i

    lr=lr2$i
    ovn-nbctl lr-add $lr

    for j in 1 2; do
        ts=ts2$j
        ovn-ic-nbctl --wait=sb --may-exist ts-add $ts

        lrp=lrp-$lr-$ts
        lsp=lsp-$ts-$lr
        # Create LRP and connect to TS
        ovn-nbctl lrp-add $lr $lrp aa:aa:aa:aa:a$j:0$i 2001:db8:$j::$i/64
        ovn-nbctl lrp-set-options $lrp route_table=rtb$j
        ovn-nbctl lsp-add $ts $lsp \
                -- lsp-set-addresses $lsp router \
                -- lsp-set-type $lsp router \
                -- lsp-set-options $lsp router-port=$lrp
    done
done

# Create directly-connected and static routes in VPC1
ovn_as az2 ovn-nbctl lrp-add lr12 lrp-lr12 aa:aa:aa:aa:bb:01 "2001:db8:200::1/64"
ovn_as az2 ovn-nbctl --route-table=rtb1 lr-route-add lr12 2001:db8:aaaa::/64 2001:db8:200::10
ovn_as az2 ovn-nbctl --route-table=rtb2 lr-route-add lr12 2001:db8:aaaa::/64 2001:db8:200::11
ovn_as az2 ovn-nbctl --route-table=rtb3 lr-route-add lr12 2001:db8:aaaa::/64 2001:db8:200::12

# Create directly-connected route in VPC2
ovn_as az2 ovn-nbctl --wait=sb lrp-add lr22 lrp-lr22 aa:aa:aa:aa:bb:01 "2001:db8:200::1/64"

# Test direct routes from lr12 were learned to lr11
#
# We need to wait twice: first time for az2/ic to handle port addition and update ic/sb and
# second time for az1/ic to handle ic/sb update.
check ovn-ic-nbctl --wait=sb sync
check ovn-ic-nbctl --wait=sb sync
AT_CHECK([ovn_as az1 ovn-nbctl lr-route-list lr11 | grep 2001:db8:200 |
             grep learned | awk '{print $1, $2, $5}' | sort], [0], [dnl
2001:db8:200::/64 2001:db8:1::2 ecmp
2001:db8:200::/64 2001:db8:2::2 ecmp
2001:db8:200::/64 2001:db8:3::2 ecmp
])

# Test static routes from lr12 rtbs rtb1,rtb2,rtb3 were learned to lr11
OVS_WAIT_UNTIL([ovn_as az1 ovn-nbctl --route-table=rtb1 lr-route-list lr11 | grep learned])
AT_CHECK([ovn_as az1 ovn-nbctl --route-table=rtb1 lr-route-list lr11], [0], [dnl
IPv6 Routes
Route Table rtb1:
       2001:db8:aaaa::/64             2001:db8:1::2 dst-ip (learned)
])
OVS_WAIT_UNTIL([ovn_as az1 ovn-nbctl --route-table=rtb2 lr-route-list lr11 | grep learned])
AT_CHECK([ovn_as az1 ovn-nbctl --route-table=rtb2 lr-route-list lr11], [0], [dnl
IPv6 Routes
Route Table rtb2:
       2001:db8:aaaa::/64             2001:db8:2::2 dst-ip (learned)
])
OVS_WAIT_UNTIL([ovn_as az1 ovn-nbctl --route-table=rtb3 lr-route-list lr11 | grep learned])
AT_CHECK([ovn_as az1 ovn-nbctl --route-table=rtb3 lr-route-list lr11], [0], [dnl
IPv6 Routes
Route Table rtb3:
       2001:db8:aaaa::/64             2001:db8:3::2 dst-ip (learned)
])

# Test routes from lr12 didn't leak as learned to lr21
OVS_WAIT_UNTIL([ovn_as az1 ovn-nbctl lr-route-list lr21 | grep "2001:db8:2::2" | grep learned])
AT_CHECK([ovn_as az1 ovn-nbctl lr-route-list lr21 | grep 2001 | sort], [0], [dnl
        2001:db8:200::/64             2001:db8:1::2 dst-ip (learned) ecmp
        2001:db8:200::/64             2001:db8:2::2 dst-ip (learned) ecmp
])

OVN_CLEANUP_IC([az1], [az2])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn-ic -- same routes destination])

ovn_init_ic_db
ovn-ic-nbctl ts-add ts1

for i in 1 2; do
    ovn_start az$i
    ovn_as az$i
    check ovn-ic-nbctl --wait=sb sync

    # Enable route learning at AZ level
    ovn-nbctl set nb_global . options:ic-route-learn=true
    ovn-nbctl set nb_global . options:ic-route-learn-default=true
    # Enable route advertising at AZ level
    ovn-nbctl set nb_global . options:ic-route-adv=true
    ovn-nbctl set nb_global . options:ic-route-adv-default=true

    lr=lr1$i
    ovn-nbctl lr-add $lr

    lrp=lrp-$lr-ts1
    lsp=lsp-ts1-$lr
    # Create LRP and connect to TS
    ovn-nbctl lrp-add $lr $lrp aa:aa:aa:aa:aa:0$i 169.254.100.$i/24
    ovn-nbctl lsp-add ts1 $lsp \
        -- lsp-set-addresses $lsp router \
        -- lsp-set-type $lsp router \
        -- lsp-set-options $lsp router-port=$lrp
    ovn-nbctl lrp-add $lr lrp-local-subnet 00:00:00:00:00:0$i 192.168.$i.1/24
    ovn-nbctl list logical-router-static-route
    check ovn-nbctl lr-route-add $lr 10.0.0.0/24 192.168.$i.10
    check ovn-nbctl --wait=sb lr-route-add $lr 0.0.0.0/0 192.168.$i.11
done

check ovn-ic-nbctl --wait=sb sync
check ovn-ic-nbctl --wait=sb sync
AT_CHECK([ovn_as az1 ovn-nbctl lr-route-list lr11 | grep dst-ip | sort] , [0], [dnl
                0.0.0.0/0              192.168.1.11 dst-ip
              10.0.0.0/24              192.168.1.10 dst-ip
           192.168.2.0/24             169.254.100.2 dst-ip (learned)
])

AT_CHECK([ovn_as az2 ovn-nbctl lr-route-list lr12 | grep dst-ip | sort], [0], [dnl
                0.0.0.0/0              192.168.2.11 dst-ip
              10.0.0.0/24              192.168.2.10 dst-ip
           192.168.1.0/24             169.254.100.1 dst-ip (learned)
])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn-ic -- route sync -- multiple logical routers])

ovn_init_ic_db
ovn-ic-nbctl ts-add ts1

for i in 1 2; do
    ovn_start az$i
    ovn_as az$i

    # Enable route learning at AZ level
    ovn-nbctl set nb_global . options:ic-route-learn=true
    # Enable route advertising at AZ level
    ovn-nbctl set nb_global . options:ic-route-adv=true
done

# Create new transit switches and LRs. Test topology is next:
#
# logical router (lr11) - transit switch (ts1) - logical router (lr21)
#                                              \- logical router (lr22)
#
# each LR has one connected subnet except TS port


# create lr11, lr21, lr22 and connect them

ovn_as az1
check ovn-ic-nbctl --wait=sb sync

lr=lr11
ovn-nbctl lr-add $lr

lrp=lrp-$lr-ts1
lsp=lsp-ts1-$lr
# Create LRP and connect to TS
ovn-nbctl lrp-add $lr $lrp aa:aa:aa:aa:a1:01 169.254.10.11/24
ovn-nbctl lsp-add ts1 $lsp \
        -- lsp-set-addresses $lsp router \
        -- lsp-set-type $lsp router \
        -- lsp-set-options $lsp router-port=$lrp

ovn_as az2
for i in 1 2; do
    lr=lr2$i
    ovn-nbctl lr-add $lr

    lrp=lrp-$lr-ts1
    lsp=lsp-ts1-$lr
    # Create LRP and connect to TS
    ovn-nbctl lrp-add $lr $lrp aa:aa:aa:aa:a2:0$i 169.254.10.2$i/24
    ovn-nbctl lsp-add ts1 $lsp \
            -- lsp-set-addresses $lsp router \
            -- lsp-set-type $lsp router \
            -- lsp-set-options $lsp router-port=$lrp
done

# Create directly-connected routes
ovn_as az1 ovn-nbctl lrp-add lr11 lrp-lr11 aa:aa:aa:aa:bb:01 "192.168.0.1/24"
ovn_as az2 ovn-nbctl lrp-add lr21 lrp-lr21 aa:aa:aa:aa:bc:01 "192.168.1.1/24"
ovn_as az2 ovn-nbctl --wait=sb lrp-add lr22 lrp-lr22 aa:aa:aa:aa:bc:02 "192.168.2.1/24"

# Test direct routes from lr21 and lr22 were learned to lr11
check ovn-ic-nbctl --wait=sb sync
check ovn-ic-nbctl --wait=sb sync
AT_CHECK([ovn_as az1 ovn-nbctl lr-route-list lr11 | grep 192.168 |
             grep learned | awk '{print $1, $2}' | sort ], [0], [dnl
192.168.1.0/24 169.254.10.21
192.168.2.0/24 169.254.10.22
])

# Test direct routes from lr11 and lr22 were learned to lr21
AT_CHECK([ovn_as az2 ovn-nbctl lr-route-list lr21 | grep 192.168 |
             grep learned | awk '{print $1, $2}' | sort ], [0], [dnl
192.168.0.0/24 169.254.10.11
192.168.2.0/24 169.254.10.22
])

# Test direct routes from lr11 and lr21 were learned to lr22
AT_CHECK([ovn_as az2 ovn-nbctl lr-route-list lr22 | grep 192.168 |
             grep learned | awk '{print $1, $2}' | sort ], [0], [dnl
192.168.0.0/24 169.254.10.11
192.168.1.0/24 169.254.10.21
])

OVN_CLEANUP_IC([az1], [az2])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn-ic -- sync ISB status to INB])
ovn_init_ic_db
net_add n1

ovn_start az1
sim_add gw-az1
as gw-az1

check ovs-vsctl add-br br-phys
ovn_az_attach az1 n1 br-phys 192.168.1.1
check ovs-vsctl set open . external-ids:ovn-is-interconn=true
as az1

# pause ovn-ic instance
check ovn-appctl -t ic/ovn-ic pause

# run sync command in the background this commands
# supposed to stuck since ovn-ic is paused.
ovn-ic-nbctl --wait=sb sync &

OVS_WAIT_UNTIL([test $(ovn-ic-nbctl get ic_nb_global . nb_ic_cfg) -gt $(ovn-ic-nbctl get ic_nb_global . sb_ic_cfg)])
AT_CHECK([ovn-ic-nbctl get ic_nb_global . nb_ic_cfg], [0], [dnl
1
])
AT_CHECK([ovn-ic-nbctl get ic_nb_global . sb_ic_cfg], [0], [dnl
0
])

# resume ovn-ic instance
check ovn-appctl -t ic/ovn-ic resume
OVS_WAIT_UNTIL([test $(ovn-ic-nbctl get ic_nb_global . nb_ic_cfg) -eq $(ovn-ic-nbctl get ic_nb_global . sb_ic_cfg)])
AT_CHECK([ovn-ic-nbctl get ic_nb_global . nb_ic_cfg], [0], [dnl
1
])
AT_CHECK([ovn-ic-nbctl get ic_nb_global . sb_ic_cfg], [0], [dnl
1
])

OVN_CLEANUP_IC([az1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn-ic -- route sync -- IPv6 denylist filter])
AT_KEYWORDS([IPv6-route-sync-denylist])

ovn_init_ic_db
check ovn-ic-nbctl ts-add ts1

for i in 1 2; do
    ovn_start az$i
    ovn_as az$i
    # Enable route learning at AZ level
    check ovn-nbctl set nb_global . options:ic-route-learn=true
    # Enable route advertising at AZ level
    check ovn-nbctl set nb_global . options:ic-route-adv=true
    # Enable denylist single filter for IPv6
    check ovn-nbctl set nb_global . options:ic-route-denylist=" \
            2003:db8:1::/64,2004:aaaa::/32,2005:1234::/21"

    check ovn-ic-nbctl --wait=sb sync
    # Create LRP and connect to TS
    check ovn-nbctl lr-add lr$i
    check ovn-nbctl lrp-add lr$i lrp-lr$i-ts1 aa:aa:aa:aa:aa:0$i \
            2001:db8:1::$i/64
    check ovn-nbctl lsp-add ts1 lsp-ts1-lr$i \
            -- lsp-set-addresses lsp-ts1-lr$i router \
            -- lsp-set-type lsp-ts1-lr$i router \
            -- lsp-set-options lsp-ts1-lr$i router-port=lrp-lr$i-ts1

    check ovn-nbctl lrp-add lr$i lrp-lr$i-p$i 00:00:00:00:00:0$i \
            2002:db8:1::$i/64

    # Create denylisted LRPs and connect to TS
    check ovn-nbctl lrp-add lr$i lrp-lr$i-p-ext$i \
            11:11:11:11:11:1$i 2003:db8:1::$i/64

    check ovn-nbctl lrp-add lr$i lrp-lr$i-p-ext2$i \
            22:22:22:22:22:2$i 2004:aaaa:bbb::$i/48

    # filtered by 2005:1234::/21 - (2005:1000: - 2005:17ff:)
    check ovn-nbctl lrp-add lr$i lrp-lr$i-p-ext3$i \
            33:33:33:33:33:3$i 2005:1734:5678::$i/50

    # additional not filtered prefix -> different subnet bits
    check ovn-nbctl --wait=sb lrp-add lr$i lrp-lr$i-p-ext4$i \
            44:44:44:44:44:4$i 2005:1834:5678::$i/50
done

check ovn-ic-nbctl --wait=sb sync
check ovn-ic-nbctl --wait=sb sync
AT_CHECK([ovn_as az1 ovn-nbctl lr-route-list lr1 |
    awk '/learned/{print $1, $2}' ], [0], [dnl
2002:db8:1::/64 2001:db8:1::2
2005:1834:5678::/50 2001:db8:1::2
])

for i in 1 2; do
    ovn_as az$i

    # Drop denylist
    check ovn-nbctl remove nb_global . options ic-route-denylist
done

check ovn-ic-nbctl --wait=sb sync
check ovn-ic-nbctl --wait=sb sync
AT_CHECK([ovn_as az1 ovn-nbctl lr-route-list lr1 |
    awk '/learned/{print $1, $2}' | sort ], [0], [dnl
2002:db8:1::/64 2001:db8:1::2
2003:db8:1::/64 2001:db8:1::2
2004:aaaa:bbb::/48 2001:db8:1::2
2005:1734:5678::/50 2001:db8:1::2
2005:1834:5678::/50 2001:db8:1::2
])

for i in 1 2; do
    ovn_as az$i

    check ovn-nbctl set nb_global . \
            options:ic-route-denylist="2003:db8:1::/64,2004:db8:1::/64"

    # Create an 'extra' denylisted LRP and connect to TS
    check ovn-nbctl lrp-add lr$i lrp-lr$i-p-ext5$i \
            55:55:55:55:55:5$i 2004:db8:1::$i/64
done

check ovn-ic-nbctl --wait=sb sync
AT_CHECK([ovn_as az1 ovn-nbctl lr-route-list lr1 |
    awk '/learned/{print $1, $2}' | sort ], [0], [dnl
2002:db8:1::/64 2001:db8:1::2
2004:aaaa:bbb::/48 2001:db8:1::2
2005:1734:5678::/50 2001:db8:1::2
2005:1834:5678::/50 2001:db8:1::2
])

OVN_CLEANUP_IC([az1], [az2])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([interconnection])
AT_KEYWORDS([slowtest])

ovn_init_ic_db
# The number needs to stay relatively low due to high memory consumption
# with address sanitizers enabled.
n_az=3
n_ts=3
for i in `seq 1 $n_az`; do
    ovn_start az$i
done

net_add n1

# 1 HV and 1 GW per AZ
for az in `seq 1 $n_az`; do
    sim_add hv$az
    as hv$az
    check ovs-vsctl add-br br-phys
    ovn_az_attach az$az n1 br-phys 192.168.$az.1 16
    for p in `seq 1 $n_ts`; do
        check ovs-vsctl -- add-port br-int vif$p -- \
            set interface vif$p external-ids:iface-id=lsp$az-$p \
            options:tx_pcap=hv$az/vif$p-tx.pcap \
            options:rxq_pcap=hv$az/vif$p-rx.pcap \
            ofport-request=$p
    done

    sim_add gw$az
    as gw$az
    check ovs-vsctl add-br br-phys
    ovn_az_attach az$az n1 br-phys 192.168.$az.2 16
    check ovs-vsctl set open . external-ids:ovn-is-interconn=true
done

for ts in `seq 1 $n_ts`; do
    AT_CHECK([ovn-ic-nbctl --wait=sb create Transit_Switch name=ts$ts], [0], [ignore])
done

for az in `seq 1 $n_az`; do
    ovn_as az$az
    check ovn-nbctl set nb_global . options:ic-route-learn=true
    check ovn-nbctl set nb_global . options:ic-route-adv=true

    # Each AZ has n_ts LSPi->LSi->LRi connecting to each TSi
    echo
    echo "az$az"
    for i in `seq 1 $n_ts`; do
        lsp_mac=00:00:00:0$az:0$i:00
        lrp_ls_mac=00:00:00:0$az:0$i:01
        lrp_ts_mac=00:00:00:0$az:0$i:02
        lsp_ip=10.$az.$i.123
        lrp_ls_ip=10.$az.$i.1
        lrp_ts_ip=169.254.$i.$az

        check ovn-nbctl ls-add ls$az-$i
        check ovn-nbctl lsp-add ls$az-$i lsp$az-$i
        check ovn-nbctl lsp-set-addresses lsp$az-$i "$lsp_mac $lsp_ip"

        check ovn-nbctl lr-add lr$az-$i

        check ovn-nbctl lrp-add lr$az-$i lrp-lr$az-$i-ls$az-$i $lrp_ls_mac $lrp_ls_ip/24
        check ovn-nbctl lsp-add ls$az-$i lsp-ls$az-$i-lr$az-$i
        check ovn-nbctl lsp-set-addresses lsp-ls$az-$i-lr$az-$i router
        check ovn-nbctl lsp-set-type lsp-ls$az-$i-lr$az-$i router
        check ovn-nbctl lsp-set-options lsp-ls$az-$i-lr$az-$i router-port=lrp-lr$az-$i-ls$az-$i

        check ovn-nbctl lrp-add lr$az-$i lrp-lr$az-$i-ts$i $lrp_ts_mac $lrp_ts_ip/24
        check ovn-nbctl lsp-add ts$i lsp-ts$i-lr$az-$i
        check ovn-nbctl lsp-set-addresses lsp-ts$i-lr$az-$i router
        check ovn-nbctl lsp-set-type lsp-ts$i-lr$az-$i router
        check ovn-nbctl lsp-set-options lsp-ts$i-lr$az-$i router-port=lrp-lr$az-$i-ts$i
        check ovn-nbctl lrp-set-gateway-chassis lrp-lr$az-$i-ts$i gw$az
    done
    check ovn-nbctl --wait=hv sync
    ovn-sbctl list Port_Binding > az$az.ports
    wait_for_ports_up
done

# Pre-populate the hypervisors' ARP tables so that we don't lose any
# packets for ARP resolution (native tunneling doesn't queue packets
# for ARP resolution).
OVN_POPULATE_ARP

for i in `seq 1 $n_az`; do
    check ovn_as az$i ovn-nbctl --wait=hv sync
    ovn_as az$i ovn-sbctl dump-flows > az$i/sbflows
done

# Allow some time for ovn-northd and ovn-controller to catch up.
# XXX This should be more systematic.
sleep 2

# Populate requested-chassis options for remote lsps
for az in $(seq 1 $n_az); do
    ovn_as az${az}
    for ts in $(seq 1 $n_ts); do
        for i in $(seq 1 $n_ts); do
            if [[ $i -eq ${az} ]]; then
                continue
            fi
            check ovn-nbctl lsp-set-options lsp-ts${ts}-lr${i}-${ts} requested-chassis=gw$i
        done
    done
done

ovn-ic-nbctl show > ic-nbctl.dump
AT_CAPTURE_FILE([ic-nbctl.dump])

(echo "---------ISB dump-----"
 ovn-ic-sbctl show
 echo "---------------------"
 ovn-ic-sbctl list gateway
 echo "---------------------"
 ovn-ic-sbctl list datapath_binding
 echo "---------------------"
 ovn-ic-sbctl list port_binding
 echo "---------------------"
 ovn-ic-sbctl list route
 echo "---------------------") > ic-sbctl.dump
AT_CAPTURE_FILE([ic-sbctl.dump])

AT_CAPTURE_FILE([expected])
AT_CAPTURE_FILE([received])
check_packets() {
    > expected
    > received
    for az in `seq 1 $n_az`; do
        for i in `seq 1 $n_ts`; do
            pcap=hv$az/vif$i-tx.pcap
            echo "--- $pcap" | tee -a expected >> received
            if test -e $az-$i.expected; then
                sort $az-$i.expected >> expected
            fi
            if test -e $pcap; then
                $PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" $pcap | sort >> received
            fi
            echo | tee -a expected >> received
        done
    done

    $at_diff expected received >/dev/null
}

# Send packets between AZs on each TS
for s_az in $(seq 1 $n_az); do
    ovn_as az${s_az}
    as hv${s_az}
    for d_az in $(seq 1 $n_az); do
        if test $s_az = $d_az; then
            continue
        fi

        for i in $(seq 1 $n_ts); do
            echo
            AS_BOX([packet from az$s_az to az$d_az via ts$i])
            lsp_smac=00:00:00:0${s_az}:0$i:00
            lsp_dmac=00:00:00:0${d_az}:0$i:00
            lrp_ls_smac=00:00:00:0${s_az}:0$i:01
            lrp_ls_dmac=00:00:00:0${d_az}:0$i:01
            lsp_sip=10.${s_az}.$i.123
            lsp_dip=10.${d_az}.$i.123

            ovn_inport=lsp${s_az}-$i
            packet="inport==\"$ovn_inport\" && eth.src==$lsp_smac && eth.dst==$lrp_ls_smac &&
                    ip4 && ip.ttl==64 && ip4.src==$lsp_sip && ip4.dst==$lsp_dip &&
                    udp && udp.src==53 && udp.dst==4369"
            echo "sending: $packet"
            AT_CHECK([ovn_trace --ovs "$packet" > ${s_az}-${d_az}-$i.ovn-trace])
            OVS_WAIT_UNTIL([ovs-appctl -t ovn-controller inject-pkt "$packet"])
            ovs_inport=$(ovs-vsctl --bare --columns=ofport find Interface external-ids:iface-id="$ovn_inport")

            ovs_packet=$(echo $packet | ovstest test-ovn expr-to-packets)
            echo ovs_inport=$ovs_inport ovs_packet=$ovs_packet
            AT_CHECK([ovs-appctl ofproto/trace br-int in_port="$ovs_inport" "$ovs_packet" > ${s_az}-${d_az}-$i.ovs-trace])

            # Packet to Expect
            # The TTL should be decremented by 2.
            packet="eth.src==$lrp_ls_dmac && eth.dst==$lsp_dmac &&
                    ip4 && ip.ttl==62 && ip4.src==$lsp_sip && ip4.dst==$lsp_dip &&
                    udp && udp.src==53 && udp.dst==4369"
            echo $packet | ovstest test-ovn expr-to-packets >> ${d_az}-$i.expected
        done
    done
done
OVS_WAIT_UNTIL([check_packets], [$at_diff -F'^---' expected received])

for az in `seq 1 $n_az`; do
    OVN_CLEANUP_SBOX([hv$az])
    OVN_CLEANUP_SBOX([gw$az])
    OVN_CLEANUP_AZ([az$az])
done

OVN_CLEANUP_IC

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([interconnection - static multicast])

# Logical network:
#
#       AZ1                     |                     AZ2
#   ---------------------------------------------------------------------
#                               |
#                               |     +-- LR2 --- LS2 --- LSP2 (sender)
#                               |     |            |
#                               |     |            +----- LSP4 (receiver)
#                               |    /
#     LSP1  --- LS1 --- LR1 --- TS ---
#   (receiver)                  |    \
#                               |     +-- LR3 --- LS3 --- LSP3 (receiver)
#
# LS1, LS2, LS3 configured to flood unregistered IP multicast.
# LR1, LR2, LR3 configured to relay IP multicast.
# LR1-LS1 configured to flood IP multicast traffic unconditionally.
# LR3-LS3 configured to flood IP multicast traffic unconditionally.

AT_CAPTURE_FILE([exp])
AT_CAPTURE_FILE([rcv])
check_packets() {
    > exp
    > rcv
    if test "$1" = --uniq; then
        sort="sort -u"; shift
    else
        sort=sort
    fi
    for tuple in "$@"; do
        set $tuple; pcap=$1 type=$2
        echo "--- $pcap" | tee -a exp >> rcv
        $sort "$type" >> exp
        $PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" $pcap | $sort >> rcv
        echo | tee -a exp >> rcv
    done

    $at_diff exp rcv >/dev/null
}

ovn_init_ic_db
ovn_start az1
ovn_start az2

net_add n1

sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
ovn_az_attach az1 n1 br-phys 192.168.1.1 16
check ovs-vsctl -- add-port br-int hv1-vif1 \
    -- set interface hv1-vif1 external-ids:iface-id=lsp1 \
       options:tx_pcap=hv1/vif1-tx.pcap \
       options:rxq_pcap=hv1/vif1-rx.pcap
check ovs-vsctl set open . external-ids:ovn-is-interconn=true

sim_add hv2
as hv2
check ovs-vsctl add-br br-phys
ovn_az_attach az2 n1 br-phys 192.168.2.1 16
check ovs-vsctl -- add-port br-int hv2-vif1 \
    -- set interface hv2-vif1 external-ids:iface-id=lsp2 \
       options:tx_pcap=hv2/vif1-tx.pcap \
       options:rxq_pcap=hv2/vif1-rx.pcap
check ovs-vsctl -- add-port br-int hv2-vif2 \
    -- set interface hv2-vif2 external-ids:iface-id=lsp3 \
       options:tx_pcap=hv2/vif2-tx.pcap \
       options:rxq_pcap=hv2/vif2-rx.pcap
check ovs-vsctl -- add-port br-int hv2-vif3 \
    -- set interface hv2-vif3 external-ids:iface-id=lsp4 \
       options:tx_pcap=hv2/vif3-tx.pcap \
       options:rxq_pcap=hv2/vif3-rx.pcap
check ovs-vsctl set open . external-ids:ovn-is-interconn=true

AT_CHECK([ovn-ic-nbctl --wait=sb create Transit_Switch name=ts], [0], [ignore])

ovn_as az1
check ovn-nbctl lr-add lr1 \
    -- lrp-add lr1 lr1-ts 00:00:00:01:00:01 42.42.42.1/24 \
    -- lrp-add lr1 lr1-ls1 00:00:00:01:01:00 43.43.43.1/24 \
    -- lrp-set-gateway-chassis lr1-ts hv1
check ovn-nbctl ls-add ls1 \
    -- lsp-add ls1 ls1-lr1 \
    -- lsp-set-addresses ls1-lr1 router \
    -- lsp-set-type ls1-lr1 router \
    -- lsp-set-options ls1-lr1 router-port=lr1-ls1 \
    -- lsp-add ls1 lsp1
check ovn-nbctl lsp-add ts ts-lr1 \
    -- lsp-set-addresses ts-lr1 router \
    -- lsp-set-type ts-lr1 router \
    -- lsp-set-options ts-lr1 router-port=lr1-ts
wait_for_ports_up

ovn_as az2
check ovn-nbctl lr-add lr2 \
    -- lrp-add lr2 lr2-ts 00:00:00:02:00:01 42.42.42.2/24 \
    -- lrp-add lr2 lr2-ls2 00:00:00:02:01:00 44.44.44.1/24 \
    -- lrp-set-gateway-chassis lr2-ts hv2
check ovn-nbctl ls-add ls2 \
    -- lsp-add ls2 ls2-lr2 \
    -- lsp-set-addresses ls2-lr2 router \
    -- lsp-set-type ls2-lr2 router \
    -- lsp-set-options ls2-lr2 router-port=lr2-ls2 \
    -- lsp-add ls2 lsp2 \
    -- lsp-add ls2 lsp4
check ovn-nbctl lsp-add ts ts-lr2 \
    -- lsp-set-addresses ts-lr2 router \
    -- lsp-set-type ts-lr2 router \
    -- lsp-set-options ts-lr2 router-port=lr2-ts

check ovn-nbctl lr-add lr3 \
    -- lrp-add lr3 lr3-ts 00:00:00:02:00:02 42.42.42.3/24 \
    -- lrp-add lr3 lr3-ls3 00:00:00:02:02:00 44.44.45.1/24 \
    -- lrp-set-gateway-chassis lr3-ts hv2
check ovn-nbctl ls-add ls3 \
    -- lsp-add ls3 ls3-lr3 \
    -- lsp-set-addresses ls3-lr3 router \
    -- lsp-set-type ls3-lr3 router \
    -- lsp-set-options ls3-lr3 router-port=lr3-ls3 \
    -- lsp-add ls3 lsp3
check ovn-nbctl lsp-add ts ts-lr3 \
    -- lsp-set-addresses ts-lr3 router \
    -- lsp-set-type ts-lr3 router \
    -- lsp-set-options ts-lr3 router-port=lr3-ts

wait_for_ports_up
check ovn-ic-nbctl --wait=sb sync
check ovn-ic-nbctl --wait=sb sync

ovn_as az1
check ovn-nbctl lsp-set-options ts-lr2 requested-chassis=hv2
check ovn-nbctl lsp-set-options ts-lr3 requested-chassis=hv2

ovn_as az2
check ovn-nbctl lsp-set-options ts-lr1 requested-chassis=hv1

dnl Enable unregistered IP multicast flooding and IP multicast relay.
ovn_as az1
check ovn-nbctl set logical_switch ls1 other_config:mcast_snoop="true" \
    other_config:mcast_flood_unregistered="true"
check ovn-nbctl set logical_router lr1 options:mcast_relay="true"
check ovn-nbctl set logical_router_port lr1-ls1 options:mcast_flood="true"

ovn_as az2
check ovn-nbctl set logical_switch ls2 other_config:mcast_snoop="true" \
    other_config:mcast_flood_unregistered="true"
check ovn-nbctl set logical_router lr2 options:mcast_relay="true"
check ovn-nbctl set logical_router_port lr2-ts options:mcast_flood="true"
check ovn-nbctl set logical_switch ls3 other_config:mcast_snoop="true" \
    other_config:mcast_flood_unregistered="true"
check ovn-nbctl set logical_router lr3 options:mcast_relay="true"
check ovn-nbctl set logical_router_port lr3-ls3 options:mcast_flood="true"

check ovn_as az1 ovn-nbctl --wait=hv sync
check ovn_as az2 ovn-nbctl --wait=hv sync

# Pre-populate the hypervisors' ARP tables so that we don't lose any
# packets for ARP resolution (native tunneling doesn't queue packets
# for ARP resolution).
OVN_POPULATE_ARP

# Send an IP multicast packet from lsp2, it should be forwarded
# statically to lsp1, lsp3 and lsp4.
> expected_az1
> expected_az2
> expected_az2_switched
send_ip_multicast_pkt hv2-vif1 hv2 \
    000000000001 01005e000144 \
    $(ip_to_hex 44 44 44 2) $(ip_to_hex 239 0 1 68) 1e 20 7c6b 11 \
    e518e518000aed350000
store_ip_multicast_pkt \
    000000010100 01005e000144 \
    $(ip_to_hex 44 44 44 2) $(ip_to_hex 239 0 1 68) 1e 1e 7e6b 11 \
    e518e518000aed350000 expected_az1
store_ip_multicast_pkt \
    000000020200 01005e000144 \
    $(ip_to_hex 44 44 44 2) $(ip_to_hex 239 0 1 68) 1e 1e 7e6b 11 \
    e518e518000aed350000 expected_az2
store_ip_multicast_pkt \
    000000000001 01005e000144 \
    $(ip_to_hex 44 44 44 2) $(ip_to_hex 239 0 1 68) 1e 20 7c6b 11 \
    e518e518000aed350000 expected_az2_switched

OVS_WAIT_UNTIL(
  [check_packets 'hv1/vif1-tx.pcap expected_az1' \
                 'hv2/vif2-tx.pcap expected_az2' \
                 'hv2/vif3-tx.pcap expected_az2_switched'],
  [$at_diff -F'^---' exp rcv])

# Send an IP multicast packet from lsp2 towards 224.0.0.x, it should be
# forwarded statically only to lsp3.
as hv1 reset_pcap_file hv1-vif1 hv1/vif1
as hv2 reset_pcap_file hv2-vif2 hv2/vif2
as hv2 reset_pcap_file hv2-vif3 hv2/vif3
> expected_az1
> expected_az2
> expected_az2_switched
send_ip_multicast_pkt hv2-vif1 hv2 \
    000000000001 01005e000144 \
    $(ip_to_hex 44 44 44 2) $(ip_to_hex 224 0 0 1) 1e 20 8cae 11 \
    e518e518000aed350000
store_ip_multicast_pkt \
    000000000001 01005e000144 \
    $(ip_to_hex 44 44 44 2) $(ip_to_hex 224 0 0 1) 1e 20 8cae 11 \
    e518e518000aed350000 expected_az2_switched

OVS_WAIT_UNTIL(
  [check_packets 'hv1/vif1-tx.pcap expected_az1' \
                 'hv2/vif2-tx.pcap expected_az2' \
                 'hv2/vif3-tx.pcap expected_az2_switched'],
  [$at_diff -F'^---' exp rcv])

OVN_CLEANUP_SBOX([hv1],["/IGMP Querier enabled without a valid IPv4 or IPv6 address/d
/IGMP Querier enabled with invalid ETH src address/d"])

OVN_CLEANUP_SBOX([hv2],["/IGMP Querier enabled without a valid IPv4 or IPv6 address/d
/IGMP Querier enabled with invalid ETH src address/d"])

OVN_CLEANUP_IC([az1],[az2])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([interconnection - IGMP/MLD multicast])
AT_KEYWORDS([IP-multicast])

# Logical network:
#
#       AZ1                     |                     AZ2
#   ---------------------------------------------------------------------
#                               |
#                               |     +-- LR2 --- LS2 --- LSP2 (sender)
#                               |    /
#     LSP1  --- LS1 --- LR1 --- TS ---
#   (receiver)                  |    \
#                               |     +-- LR3 --- LS3 --- LSP3 (receiver)
#
# LS1, LS2, LS3, TS configured to snoop IP multicast.
# LR1, LR2, LR3 configured to relay IP multicast.
# LR1-TS configured to flood IP multicast traffic unconditionally.
# LR2-TS configured to flood IP multicast traffic unconditionally.
# LR3-TS configured to flood IP multicast traffic unconditionally.

AT_CAPTURE_FILE([exp])
AT_CAPTURE_FILE([rcv])
check_packets() {
    > exp
    > rcv
    if test "$1" = --uniq; then
        sort="sort -u"; shift
    else
        sort=sort
    fi
    for tuple in "$@"; do
        set $tuple; pcap=$1 type=$2
        echo "--- $pcap" | tee -a exp >> rcv
        $sort "$type" >> exp
        $PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" $pcap | $sort >> rcv
        echo | tee -a exp >> rcv
    done

    $at_diff exp rcv >/dev/null
}

ovn_init_ic_db
ovn_start az1
ovn_start az2

net_add n1

sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
ovn_az_attach az1 n1 br-phys 192.168.1.1 16
check ovs-vsctl -- add-port br-int hv1-vif1 \
    -- set interface hv1-vif1 external-ids:iface-id=lsp1 \
       options:tx_pcap=hv1/vif1-tx.pcap \
       options:rxq_pcap=hv1/vif1-rx.pcap
check ovs-vsctl set open . external-ids:ovn-is-interconn=true

sim_add hv2
as hv2
check ovs-vsctl add-br br-phys
ovn_az_attach az2 n1 br-phys 192.168.2.1 16
check ovs-vsctl -- add-port br-int hv2-vif1 \
    -- set interface hv2-vif1 external-ids:iface-id=lsp2 \
       options:tx_pcap=hv2/vif1-tx.pcap \
       options:rxq_pcap=hv2/vif1-rx.pcap
check ovs-vsctl -- add-port br-int hv2-vif2 \
    -- set interface hv2-vif2 external-ids:iface-id=lsp3 \
       options:tx_pcap=hv2/vif2-tx.pcap \
       options:rxq_pcap=hv2/vif2-rx.pcap
check ovs-vsctl set open . external-ids:ovn-is-interconn=true

AT_CHECK([ovn-ic-nbctl --wait=sb create Transit_Switch name=ts], [0], [ignore])
check ovn_as az1 ovn-nbctl wait-until logical_switch ts
check ovn_as az2 ovn-nbctl wait-until logical_switch ts

ovn_as az1
check ovn-nbctl lr-add lr1 \
    -- lrp-add lr1 lr1-ts 00:00:00:01:00:01 42.42.42.1/24 4242::1/64 \
    -- lrp-add lr1 lr1-ls1 00:00:00:01:01:00 43.43.43.1/24 4343::1/64\
    -- lrp-set-gateway-chassis lr1-ts hv1
check ovn-nbctl ls-add ls1 \
    -- lsp-add ls1 ls1-lr1 \
    -- lsp-set-addresses ls1-lr1 router \
    -- lsp-set-type ls1-lr1 router \
    -- lsp-set-options ls1-lr1 router-port=lr1-ls1 \
    -- lsp-add ls1 lsp1
check ovn-nbctl lsp-add ts ts-lr1 \
    -- lsp-set-addresses ts-lr1 router \
    -- lsp-set-type ts-lr1 router \
    -- lsp-set-options ts-lr1 router-port=lr1-ts
wait_for_ports_up

ovn_as az2
check ovn-nbctl lr-add lr2 \
    -- lrp-add lr2 lr2-ts 00:00:00:02:00:01 42.42.42.2/24 4242::2/64 \
    -- lrp-add lr2 lr2-ls2 00:00:00:02:01:00 44.44.44.1/24 4444::1/64 \
    -- lrp-set-gateway-chassis lr2-ts hv2
check ovn-nbctl ls-add ls2 \
    -- lsp-add ls2 ls2-lr2 \
    -- lsp-set-addresses ls2-lr2 router \
    -- lsp-set-type ls2-lr2 router \
    -- lsp-set-options ls2-lr2 router-port=lr2-ls2 \
    -- lsp-add ls2 lsp2
check ovn-nbctl lsp-add ts ts-lr2 \
    -- lsp-set-addresses ts-lr2 router \
    -- lsp-set-type ts-lr2 router \
    -- lsp-set-options ts-lr2 router-port=lr2-ts

check ovn-nbctl lr-add lr3 \
    -- lrp-add lr3 lr3-ts 00:00:00:02:00:02 42.42.42.3/24 4242::3/64 \
    -- lrp-add lr3 lr3-ls3 00:00:00:02:02:00 44.44.45.1/24 4445::1/64 \
    -- lrp-set-gateway-chassis lr3-ts hv2
check ovn-nbctl ls-add ls3 \
    -- lsp-add ls3 ls3-lr3 \
    -- lsp-set-addresses ls3-lr3 router \
    -- lsp-set-type ls3-lr3 router \
    -- lsp-set-options ls3-lr3 router-port=lr3-ls3 \
    -- lsp-add ls3 lsp3
check ovn-nbctl lsp-add ts ts-lr3 \
    -- lsp-set-addresses ts-lr3 router \
    -- lsp-set-type ts-lr3 router \
    -- lsp-set-options ts-lr3 router-port=lr3-ts

wait_for_ports_up
check ovn-ic-nbctl --wait=sb sync
check ovn-ic-nbctl --wait=sb sync
ovn_as az1
check ovn-nbctl lsp-set-options ts-lr2 requested-chassis=hv2
check ovn-nbctl lsp-set-options ts-lr3 requested-chassis=hv2

ovn_as az2
check ovn-nbctl lsp-set-options ts-lr1 requested-chassis=hv1

dnl Enable IP multicast snooping and IP multicast relay.  Reports are
dnl forwarded statically.
ovn_as az1
check ovn-nbctl set logical_switch ls1 other_config:mcast_snoop="true"
check ovn-nbctl set Logical_Switch_Port ls1-lr1 options:mcast_flood_reports="true"
check ovn-nbctl set logical_router lr1 options:mcast_relay="true"
check ovn-nbctl set logical_router_port lr1-ts options:mcast_flood="true"
check ovn-nbctl set logical_switch ts other_config:mcast_snoop="true"
check ovn-nbctl set logical_switch_port ts-lr1 options:mcast_flood_reports="true"
check ovn-nbctl set logical_switch_port ts-lr2 options:mcast_flood_reports="true"
check ovn-nbctl set logical_switch_port ts-lr3 options:mcast_flood_reports="true"

ovn_as az2
check ovn-nbctl set logical_switch ls2 other_config:mcast_snoop="true"
check ovn-nbctl set Logical_Switch_Port ls2-lr2 options:mcast_flood_reports="true"
check ovn-nbctl set logical_router lr2 options:mcast_relay="true"
check ovn-nbctl set logical_router_port lr2-ts options:mcast_flood="true"
check ovn-nbctl set logical_switch ls3 other_config:mcast_snoop="true"
check ovn-nbctl set Logical_Switch_Port ls3-lr3 options:mcast_flood_reports="true"
check ovn-nbctl set logical_router lr3 options:mcast_relay="true"
check ovn-nbctl set logical_router_port lr3-ts options:mcast_flood="true"
check ovn-nbctl set logical_switch ts other_config:mcast_snoop="true"
check ovn-nbctl set logical_switch_port ts-lr1 options:mcast_flood_reports="true"
check ovn-nbctl set logical_switch_port ts-lr2 options:mcast_flood_reports="true"
check ovn-nbctl set logical_switch_port ts-lr3 options:mcast_flood_reports="true"

check ovn_as az1 ovn-nbctl --wait=hv sync
check ovn_as az2 ovn-nbctl --wait=hv sync

# Pre-populate the hypervisors' ARP tables so that we don't lose any
# packets for ARP resolution (native tunneling doesn't queue packets
# for ARP resolution).
OVN_POPULATE_ARP

# Inject IGMP Join for 239.0.1.68 on LSP1.
send_igmp_v3_report hv1-vif1 hv1 \
    000000000001 $(ip_to_hex 10 0 0 1) f9f8 \
    $(ip_to_hex 239 0 1 68) 04 e9b9 \
    /dev/null

# Inject MLD Join for ff0a:dead:beef::1 on LSP1.
send_mld_v2_report hv1-vif1 hv1 \
    000000000001 10000000000000000000000000000001 \
    ff0adeadbeef00000000000000000001 04 c0e4 \
    /dev/null

# Inject IGMP Join for 239.0.1.68 on LSP3.
send_igmp_v3_report hv2-vif2 hv2 \
    000000000001 $(ip_to_hex 10 0 0 1) f9f8 \
    $(ip_to_hex 239 0 1 68) 04 e9b9 \
    /dev/null

# Inject MLD Join for ff0a:dead:beef::1 on LSP3.
send_mld_v2_report hv2-vif2 hv2 \
    000000000001 10000000000000000000000000000001 \
    ff0adeadbeef00000000000000000001 04 c0e4 \
    /dev/null

# Check that the IGMP and MLD groups are learned on both AZs (on the LS
# and TS).
ovn_as az1
wait_row_count IGMP_Group 2 address=239.0.1.68
wait_row_count IGMP_Group 2 address='"ff0a:dead:beef::1"'
check ovn-nbctl --wait=hv sync

ovn_as az2
wait_row_count IGMP_Group 2 address=239.0.1.68
wait_row_count IGMP_Group 2 address='"ff0a:dead:beef::1"'
check ovn-nbctl --wait=hv sync

# Send an IP multicast packet from LSP2, it should be forwarded
# to lsp1 and lsp3.
> expected_az1
> expected_az2
send_ip_multicast_pkt hv2-vif1 hv2 \
    000000000001 01005e000144 \
    $(ip_to_hex 44 44 44 2) $(ip_to_hex 239 0 1 68) 1e 20 7c6b 11 \
    e518e518000aed350000
store_ip_multicast_pkt \
    000000010100 01005e000144 \
    $(ip_to_hex 44 44 44 2) $(ip_to_hex 239 0 1 68) 1e 1e 7e6b 11 \
    e518e518000aed350000 expected_az1
store_ip_multicast_pkt \
    000000020200 01005e000144 \
    $(ip_to_hex 44 44 44 2) $(ip_to_hex 239 0 1 68) 1e 1e 7e6b 11 \
    e518e518000aed350000 expected_az2

send_ip6_multicast_pkt hv2-vif1 hv2 \
    000000000001 333300000001 \
    00100000000000000000000000000042 ff0adeadbeef00000000000000000001 \
    000e 40 11 \
    93407a69000e2b4e61736461640a
store_ip6_multicast_pkt \
    000000010100 333300000001 \
    00100000000000000000000000000042 ff0adeadbeef00000000000000000001 \
    000e 3e 11 \
    93407a69000e2b4e61736461640a \
    expected_az1
store_ip6_multicast_pkt \
    000000020200 333300000001 \
    00100000000000000000000000000042 ff0adeadbeef00000000000000000001 \
    000e 3e 11 \
    93407a69000e2b4e61736461640a \
    expected_az2

OVS_WAIT_UNTIL(
  [check_packets 'hv1/vif1-tx.pcap expected_az1' \
                 'hv2/vif2-tx.pcap expected_az2'],
  [$at_diff -F'^---' exp rcv])

OVN_CLEANUP_SBOX([hv1], ["/IGMP Querier enabled without a valid IPv4/d
/IGMP Querier enabled with invalid ETH src/d"])

OVN_CLEANUP_SBOX([hv2], ["/IGMP Querier enabled without a valid IPv4/d
/IGMP Querier enabled with invalid ETH src/d"])

OVN_CLEANUP_IC([az1],[az2])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([interconnection - IGMP/MLD multicast - TS flood])
AT_KEYWORDS([IP-multicast])

# Logical network:
#
#       AZ1                     |                     AZ2
#   ---------------------------------------------------------------------
#                               |
#                               |     +-- LR2 --- LS2 --- LSP2 (sender)
#                               |    /
#     LSP1  --- LS1 --- LR1 --- TS ---
#   (receiver)                  |    \
#                               |     +-- LR3 --- LS3 --- LSP3 (receiver)
#
# LS1, LS2, LS3, TS configured to snoop IP multicast.
# LR1, LR2, LR3 configured to relay IP multicast.
# LR1-TS configured to flood IP multicast traffic unconditionally.
# LR2-TS configured to flood IP multicast traffic unconditionally.
# LR3-TS configured to flood IP multicast traffic unconditionally.

AT_CAPTURE_FILE([exp])
AT_CAPTURE_FILE([rcv])
check_packets() {
    > exp
    > rcv
    if test "$1" = --uniq; then
        sort="sort -u"; shift
    else
        sort=sort
    fi
    for tuple in "$@"; do
        set $tuple; pcap=$1 type=$2
        echo "--- $pcap" | tee -a exp >> rcv
        $sort "$type" >> exp
        $PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" $pcap | $sort >> rcv
        echo | tee -a exp >> rcv
    done

    $at_diff exp rcv >/dev/null
}

ovn_init_ic_db
ovn_start az1
ovn_start az2

net_add n1

sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
ovn_az_attach az1 n1 br-phys 192.168.1.1 16
check ovs-vsctl -- add-port br-int hv1-vif1 \
    -- set interface hv1-vif1 external-ids:iface-id=lsp1 \
       options:tx_pcap=hv1/vif1-tx.pcap \
       options:rxq_pcap=hv1/vif1-rx.pcap
check ovs-vsctl set open . external-ids:ovn-is-interconn=true

sim_add hv2
as hv2
check ovs-vsctl add-br br-phys
ovn_az_attach az2 n1 br-phys 192.168.2.1 16
check ovs-vsctl -- add-port br-int hv2-vif1 \
    -- set interface hv2-vif1 external-ids:iface-id=lsp2 \
       options:tx_pcap=hv2/vif1-tx.pcap \
       options:rxq_pcap=hv2/vif1-rx.pcap
check ovs-vsctl -- add-port br-int hv2-vif2 \
    -- set interface hv2-vif2 external-ids:iface-id=lsp3 \
       options:tx_pcap=hv2/vif2-tx.pcap \
       options:rxq_pcap=hv2/vif2-rx.pcap
check ovs-vsctl set open . external-ids:ovn-is-interconn=true

AT_CHECK([ovn-ic-nbctl --wait=sb create Transit_Switch name=ts], [0], [ignore])
check ovn_as az1 ovn-nbctl wait-until logical_switch ts
check ovn_as az2 ovn-nbctl wait-until logical_switch ts

ovn_as az1
check ovn-nbctl lr-add lr1 \
    -- lrp-add lr1 lr1-ts 00:00:00:01:00:01 42.42.42.1/24 4242::1/64 \
    -- lrp-add lr1 lr1-ls1 00:00:00:01:01:00 43.43.43.1/24 4343::1/64\
    -- lrp-set-gateway-chassis lr1-ts hv1
check ovn-nbctl ls-add ls1 \
    -- lsp-add ls1 ls1-lr1 \
    -- lsp-set-addresses ls1-lr1 router \
    -- lsp-set-type ls1-lr1 router \
    -- lsp-set-options ls1-lr1 router-port=lr1-ls1 \
    -- lsp-add ls1 lsp1
check ovn-nbctl lsp-add ts ts-lr1 \
    -- lsp-set-addresses ts-lr1 router \
    -- lsp-set-type ts-lr1 router \
    -- lsp-set-options ts-lr1 router-port=lr1-ts
wait_for_ports_up

ovn_as az2
check ovn-nbctl lr-add lr2 \
    -- lrp-add lr2 lr2-ts 00:00:00:02:00:01 42.42.42.2/24 4242::2/64 \
    -- lrp-add lr2 lr2-ls2 00:00:00:02:01:00 44.44.44.1/24 4444::1/64 \
    -- lrp-set-gateway-chassis lr2-ts hv2
check ovn-nbctl ls-add ls2 \
    -- lsp-add ls2 ls2-lr2 \
    -- lsp-set-addresses ls2-lr2 router \
    -- lsp-set-type ls2-lr2 router \
    -- lsp-set-options ls2-lr2 router-port=lr2-ls2 \
    -- lsp-add ls2 lsp2
check ovn-nbctl lsp-add ts ts-lr2 \
    -- lsp-set-addresses ts-lr2 router \
    -- lsp-set-type ts-lr2 router \
    -- lsp-set-options ts-lr2 router-port=lr2-ts

check ovn-nbctl lr-add lr3 \
    -- lrp-add lr3 lr3-ts 00:00:00:02:00:02 42.42.42.3/24 4242::3/64 \
    -- lrp-add lr3 lr3-ls3 00:00:00:02:02:00 44.44.45.1/24 4445::1/64 \
    -- lrp-set-gateway-chassis lr3-ts hv2
check ovn-nbctl ls-add ls3 \
    -- lsp-add ls3 ls3-lr3 \
    -- lsp-set-addresses ls3-lr3 router \
    -- lsp-set-type ls3-lr3 router \
    -- lsp-set-options ls3-lr3 router-port=lr3-ls3 \
    -- lsp-add ls3 lsp3
check ovn-nbctl lsp-add ts ts-lr3 \
    -- lsp-set-addresses ts-lr3 router \
    -- lsp-set-type ts-lr3 router \
    -- lsp-set-options ts-lr3 router-port=lr3-ts

wait_for_ports_up
check ovn-ic-nbctl --wait=sb sync
check ovn-ic-nbctl --wait=sb sync
ovn_as az1
check ovn-nbctl lsp-set-options ts-lr2 requested-chassis=hv2
check ovn-nbctl lsp-set-options ts-lr3 requested-chassis=hv2

ovn_as az2
check ovn-nbctl lsp-set-options ts-lr1 requested-chassis=hv1

dnl Enable IP multicast snooping and IP multicast relay.  Reports are
dnl forwarded statically.
ovn_as az1
check ovn-nbctl set logical_switch ls1 other_config:mcast_snoop="true"
check ovn-nbctl set logical_router lr1 options:mcast_relay="true"
check ovn-nbctl set logical_router_port lr1-ts options:mcast_flood="true"
check ovn-nbctl set logical_switch ts other_config:mcast_snoop="true"
check ovn-nbctl set logical_switch ts other_config:mcast_flood_unregistered="true"

ovn_as az2
check ovn-nbctl set logical_switch ls2 other_config:mcast_snoop="true"
check ovn-nbctl set logical_router lr2 options:mcast_relay="true"
check ovn-nbctl set logical_router_port lr2-ts options:mcast_flood="true"
check ovn-nbctl set logical_switch ls3 other_config:mcast_snoop="true"
check ovn-nbctl set logical_router lr3 options:mcast_relay="true"
check ovn-nbctl set logical_router_port lr3-ts options:mcast_flood="true"
check ovn-nbctl set logical_switch ts other_config:mcast_snoop="true"
check ovn-nbctl set logical_switch ts other_config:mcast_flood_unregistered="true"

check ovn_as az1 ovn-nbctl --wait=hv sync
check ovn_as az2 ovn-nbctl --wait=hv sync

# Pre-populate the hypervisors' ARP tables so that we don't lose any
# packets for ARP resolution (native tunneling doesn't queue packets
# for ARP resolution).
OVN_POPULATE_ARP

# Inject IGMP Join for 239.0.1.68 on LSP1.
send_igmp_v3_report hv1-vif1 hv1 \
    000000000001 $(ip_to_hex 10 0 0 1) f9f8 \
    $(ip_to_hex 239 0 1 68) 04 e9b9 \
    /dev/null

# Inject MLD Join for ff0a:dead:beef::1 on LSP1.
send_mld_v2_report hv1-vif1 hv1 \
    000000000001 10000000000000000000000000000001 \
    ff0adeadbeef00000000000000000001 04 c0e4 \
    /dev/null

# Inject IGMP Join for 239.0.1.68 on LSP3.
send_igmp_v3_report hv2-vif2 hv2 \
    000000000001 $(ip_to_hex 10 0 0 1) f9f8 \
    $(ip_to_hex 239 0 1 68) 04 e9b9 \
    /dev/null

# Inject MLD Join for ff0a:dead:beef::1 on LSP3.
send_mld_v2_report hv2-vif2 hv2 \
    000000000001 10000000000000000000000000000001 \
    ff0adeadbeef00000000000000000001 04 c0e4 \
    /dev/null

# Check that the IGMP and MLD groups are learned on both AZs (on the LS
# and TS).
ovn_as az1
wait_row_count IGMP_Group 2 address=239.0.1.68
wait_row_count IGMP_Group 2 address='"ff0a:dead:beef::1"'
check ovn-nbctl --wait=hv sync

ovn_as az2
wait_row_count IGMP_Group 2 address=239.0.1.68
wait_row_count IGMP_Group 2 address='"ff0a:dead:beef::1"'
check ovn-nbctl --wait=hv sync

# Send an IP multicast packet from LSP2, it should be forwarded
# to lsp1 and lsp3.
> expected_az1
> expected_az2
send_ip_multicast_pkt hv2-vif1 hv2 \
    000000000001 01005e000144 \
    $(ip_to_hex 44 44 44 2) $(ip_to_hex 239 0 1 68) 1e 20 7c6b 11 \
    e518e518000aed350000
store_ip_multicast_pkt \
    000000010100 01005e000144 \
    $(ip_to_hex 44 44 44 2) $(ip_to_hex 239 0 1 68) 1e 1e 7e6b 11 \
    e518e518000aed350000 expected_az1
store_ip_multicast_pkt \
    000000020200 01005e000144 \
    $(ip_to_hex 44 44 44 2) $(ip_to_hex 239 0 1 68) 1e 1e 7e6b 11 \
    e518e518000aed350000 expected_az2

send_ip6_multicast_pkt hv2-vif1 hv2 \
    000000000001 333300000001 \
    00100000000000000000000000000042 ff0adeadbeef00000000000000000001 \
    000e 40 11 \
    93407a69000e2b4e61736461640a
store_ip6_multicast_pkt \
    000000010100 333300000001 \
    00100000000000000000000000000042 ff0adeadbeef00000000000000000001 \
    000e 3e 11 \
    93407a69000e2b4e61736461640a \
    expected_az1
store_ip6_multicast_pkt \
    000000020200 333300000001 \
    00100000000000000000000000000042 ff0adeadbeef00000000000000000001 \
    000e 3e 11 \
    93407a69000e2b4e61736461640a \
    expected_az2

OVS_WAIT_UNTIL(
  [check_packets 'hv1/vif1-tx.pcap expected_az1' \
                 'hv2/vif2-tx.pcap expected_az2'],
  [$at_diff -F'^---' exp rcv])

OVN_CLEANUP_SBOX([hv1], ["/IGMP Querier enabled without a valid IPv4/d
/IGMP Querier enabled with invalid ETH src/d"])

OVN_CLEANUP_SBOX([hv2], ["/IGMP Querier enabled without a valid IPv4/d
/IGMP Querier enabled with invalid ETH src/d"])

OVN_CLEANUP_IC([az1],[az2])
AT_CLEANUP
])
